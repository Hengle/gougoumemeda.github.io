---
layout:     post
title:      "Waps STM中随手写的一些web库"
subtitle:   "认真工作，养(xiao)家(sa)糊(ren)口(sheng)"
date:       2017-10-09 16:17:00
author:     "George"
header-img: "img/post-bg-wap.jpg"
tags:
    - Works Applications
    - Web
    - 技术
---

## 前言

十一长假结束后，公司STM的第二个assignment也要进入尾声了。有了第一个assignment的经验，这次在具体开发的过程中遇到的问题就少了很多，我也把更多的重心放在了组件化上，尝试着去写一些公共的库文件来供他人使用。

## 正文

在这次的开发中，我一共提取出了三个公共库，分别与滑杆，分页器与图表有关。我将其相关的代码写在各自的文件中，使用一个类来封装，其他人使用时，只需要声明一个新的对象然后传入相应的参数即可，不需要关注其具体的实现。下面我将各自介绍这些库的实现细节与使用方法。

### Slider
这是一个滑杆库，[点我下载slider.js](/js/slider.js)。目前该slider使用的是双向设计，即有两个滑块，他们中间的范围为最终我们需要的值，设计图如下所示。

![img](/img/in-post/WAP/slider.png)

所接受的参数如下：

```
config: {
	name: string, // 该slider的名字
    target: jQuery Object, // 该slider所要放置的jQuery对象
    width: float, // slider的宽度
    height: float, // slider的高度
    barHeight: float, // slider中滑杆的高度，该值需要小于height
	extremum: { // slider的两个端值
        l: float,
        r: float
    },
    initial: { // slider的两个初始值
        l: float, 
        r: float
    },
    beginDrag: function, // 开始滑动滑块时触发的操作
    endDrag: function // 结束滑动滑块时触发的操作
}
```

整体实现的思路非常清晰，大致如下：
- 绘制滑杆，并且上色
- 根据slider的宽度、端值以及初始值绘制左滑块与右滑块
- 在左滑块与右滑块的中间添加一个```validZone```，表示当前有效的范围，高度为```barHeight```，并且进行上色（配色尽量与滑杆的颜色进行搭配）
- 绘制滑块Label，显示当前的数值
- 绑定事件

在实现的过程中并没有太多困难的地方，唯一可能牵扯到一些数学知识的，应该就是计算滑块的位置。我们以左滑块为例，如果要计算它的初始位置，则公式如下：

```
(initial.l - extreme.l) / (extreme.r - extreme.l) * width
```

同理，如果我们已知左滑块的位置，要计算左滑块的值，可以通过如下的公式：

```
extreme.l + (leftPos / width) * (extreme.r - extreme.l)
```

在滑块滑动的过程中，我们会经常用到上述的两个公式，因此需要掌握其背后的原理（也是非常显而易见的）。

### Pagination

在大学期间，我已经多次实现过分页器，但是都没有将其独立的作为一个模块拎出来。这一次用类来封装，也是希望能够测验一下自己对分页器的理解。

很久之前就聊过，分页器分为前端分页和后端分页。在本项目中，由于我们没有构建一个独立的服务端，因此这里实现的分页器采用的是前端分页。后端分页如果要实现的话，对数据层的控制力度可能就要小一些，因为所有的数据都是从后台传进去的，分页器只是做了一个显示的作用。而前端分页不仅仅是显示，真正的分页过程也在这里进行，因此对分页器的封装更加友好。需要使用的朋友可以[点我下载pagination.js](/js/pagination2.js)。

最终的设计图如下：

![img](/img/in-post/WAP/pagination.png)

所接受的参数如下：

```
config: {
    name: string, // 分页器的名字
    target: jQuery.Object, // 分页器要放置的jQuery对象
    data: [], // 分页数据
    maxNumberOfButton: int, // 分页器最多同时显示的页码数量
    eachPageNumber: int, // 每个页面的条目数量
    clickEvent: function // 点击分页器页码时触发的操作
}
```

实现的思路如下：
- 初始化分页器，计算总共的页码数量，分页器同时显示的页码数量（小于或者等于```maxNumberOfButton```）以及所要显示的页码。
- 绘制分页器。如果是第一页，则向左按钮失效（添加类```disabled```），如果是最后一页，则向右按钮失效
- 点击事件，对传入的数据进行分页，并且重新绘制分页器。

相对来说，比较复杂的在于第三步点击事件，这里我们需要重新计算所要显示的页码。定义当前页码为```curr```，所要显示的页码数量的一半为```mid```，总页码数为```total```。

如果```maxNumberOfButton```小于```total```，那么我们可能会隐藏一部分页码不显示。例如，我们最大能够显示的页码量为5，但是这时候一共有7页，那么初始情况下需要显示的页码为1，2，3，4，5。第六页和第七页我们将其隐藏。如果我们单击页码4，那么需要显示的页码就变成了2，3，4，5，6。

大致上来看，我们可以将需要显示的页码分为三类，则：
1. ```curr >= 1 && curr <= mid```，则需要显示的页码为```1 ~ maxNumberOfButton```。
2. ```curr <= total && curr >= total - mid + 1```，则需要显示的页码为```total - maxNumberOfButton + 1 ~ total```
3. 除此之外，需要显示的页码为，```curr - mid ~ curr + mid (- 1, 当maxNumberOfButton为偶数时)```

可以看到，在第三种情况中，当前的页码始终处于分页器的中间位置。

整个分页器的难点就在于理清楚这三种情况。对于后端分页，我们就不再需要传入data，也不需要实际的分页操作，仅仅绘制分页器即可。

### Chart

图表是最为难以实现的一个模块库。在本项目中，我一共实现了三种类型的图表，无论从种类上还是性能上，都无法与市面上目前已经成熟的图表类库进行比较（例如acharts）。因此，对于我个人而言，这是一个完成项目所必须完成的工作，也是锻炼我js能力的一次考验。

我将三种类型的图表写在了同一个文件中，[点我下载chart.js](/js/chart.js)，下面我将一个一个介绍。

#### Histogram （这里译名有点奇怪，我的锅，其实就是bar chart）

先来看一张效果图：

![img](/img/in-post/WAP/histogram.png)

所接受的参数如下：

```
config: {
	name: string, // 柱状图的名字
	target: jQuery Object, // 柱状图所要放置的jQuery对象
	height: int, // 柱状图的高度
	width: int, // 柱状图的宽度
	legend: string, // 图例
	clickEvent: function, // 点击柱状图事件
	color: string, // 柱状图的颜色
	xAsix: Array, // 横坐标数据
	yAsix: Array // 横坐标数据所对应的值
}
```

实现的思路如下：
- 初始化坐标系，确定纵坐标的方向（正/负/双向）。
- 绘制图例
- 绘制纵坐标，根据```yAsix```计算出纵坐标的最大值以及划分线的数量
- 绘制横坐标，动态绘制柱状条，并且在柱状体条上方添加数值标签
- 绑定鼠标覆盖事件以及点击事件

其中，最为复杂的应该是绘制纵坐标以及动态绘制柱状条这两步。

在绘制纵坐标中，我们需要先确定坐标轴的最大值。我们简单的通过yAsix中的最大值的最高位加一的方法来确定纵坐标端值。比如，如果```yAsix```中最大值为75000，则坐标轴的最大值为80000；如果是98000，则最大值为100000。负数亦然，我们得到了```_yPositivePeak``` 和 ```_yNegativePeak```。接着我们需要计算出纵坐标轴正负两端划分线的数量。对于正负两端最大值数位多的那一端（假设为正方向端，即 ```_yPositivePeak.str().length > _yNegativePeak.str().length```)，其划分线的数量就是最高位（例外是，如果最高位为1，则数量为10）；数位少的那一端，通常情况下划分线的数量就是1。举个例子， ```_yPositivePeak```为70000， ```_yNegativePeak```为-3000，则正方向的划分线数量为7，具体是10000，20000，30000，40000，50000，60000，70000；负方向的划分线数量为1，具体是-3000。

细心的读者可以发现，对于数位少的一端，我在划分线数量为1的前面加了一个定语“通常”，也就是说，有例外发生。这种情况出现在，两端最大值数位差为1，并且数位多的那一端的最高位为1（即 ```_yPositivePeak.str().length - _yNegativePeak.str().length == 1 && _yPositivePeak.str()[0] == '1'```)。再这样的情况下，数位少的那一端划分线的数量也是其最高位。比如说， ```_yPositivePeak```为100000， ```_yNegativePeak```为-40000，则正方向的划分线数量为10，具体是10000，20000，30000，40000，50000，60000，70000，80000，90000，100000；负方向的划分线数量为4，即-10000，-20000，-30000，-40000。

这么设计看上去会有一些复杂，但是为了坐标轴更为美观，采用这样的方法我认为是很有必要的。他避免了两个问题：
1. 两端端值数位相差过大时，数位小的那一端划分线过于紧凑
2. 两端端值数位相差不大时，数位小的那一端划分线过于松散

一句话来概括的话，就是正负两端划分线的间距要尽量保持一样，如果正方向划分线的间距时10000，那么负方向也要保持10000，否则就不划分（划分线数量为1）。这是一种保证柱状图坐标轴不会太丑的方法。

第二个难点在于，如何动态绘制柱状条。这里我们用到了css3中的```-webkit-transition```。我们对每一个柱状条进行如下的css设置：

```
.bar{
    height: 0;
    '-webkit-transition': 'height 1s'
}
```

在将其加入到dom树之后，修改他的height为实际的高度，就能触发动画效果。

#### Pie chart

现在我们将介绍饼图，老样子还是先看图：

![img](/img/in-post/WAP/piechart.png)

所接受的参数如下：

```
config: {
	name: string // 饼图的名字
	target: jQuery Object, // 饼图所放置的jQuery对象
	height: int, // 饼图的高度
	width: int, // 饼图的宽度
	legend: string, // 图例
	clickEvent: function, // 点击事件 
	data:[{ // 饼图的数据，包括文字描述，数据以及扇形的颜色
		label: string,
		value: int,
		color: string
	}]
}
```

实现的思路如下：
- 初始化饼图，这里我们使用canvas来绘制
- 绘制饼图。如果是第一次绘制，则使用动画效果
- 绑定鼠标移动事件，在移动的过程中不停的重绘饼图，同时判断鼠标的位置是否在某一个扇形路径内，如果在，则可认为当前鼠标的位置覆盖了该扇形
- 绑定鼠标点击事件

在饼图中，最为复杂的一点在于如何判断鼠标是覆盖了哪一块扇形。因为扇形是不规则的，我们不能像柱状图那样使用div来绘制，因此只能够使用canvas。而在canvas中，所有的图像都是一个整体，没有办法对每一个扇形进行单独的事件绑定，而需要通过```canvas.getContext('2d').isPointInPath(x, y)```来判断一个坐标是否在canvas中的某一个路径内。在饼图中，我们按照顺时针的方向来绘制扇形，扇形路径绘制完毕后，我们马上进行```isPointInPath()```的判定，就能够知道鼠标当前所覆盖的扇形是哪一个。这也就需要在mousemove事件中不停的重绘饼图，因为鼠标的坐标是不停的变化的。我原本以为这种方法的性能消耗会非常大，但事实上来看似乎并没有卡死的现象。如果有更好的方法也希望大家能够告知。

除了判断鼠标位置所在的扇形之外，另一个有点难度的地方在于如何动态绘制饼图。所谓动态绘制，就是一点一点的来画图。原本可能90°的扇形一次性画完，动态绘制就将其分成90份，每次只绘制1°的扇形，重复绘制90次。理所应当的我们需要使用```setInterval```函数，来重复绘制操作。绘制之前，我们先顺时针扫一遍所有的扇形，然后将扇形的终弧度保存在一个数组```angles```中，以备后用，同时记录下当前正在绘制的度数 _timerCurrDraw。在具体的小角度的绘制过程中，我们先判定当前绘制的是哪一个扇形（通过 ```_timerCurrDraw```与```angles```中的元素进行比较），来决定绘制的颜色，然后进行path的绘制并且上色即可。如果 ```_timerCurrDraw```大于了最后一个扇形的终弧度（为2π），则动态绘制结束。

#### Scatter diagram
翻译上来看，就是所谓的散点图，但其实与我们常见的散点图还有一些区别。除了点的分布以外，我所设计的scatter diagram还将空间分成了四个部分，每个部分都有其实际意义。对于点的分布，我也添加了一些新的含义，不同的颜色表示点不同的种类，而点的颜色深浅与半径的大小也区分了其在该类型中的等级。

效果图如下：

![img](/img/in-post/WAP/scatter.png)

所接受的参数如下：

```
config: {
	name: string // 散点图的名字
	target: jQuery Object, // 散点图所在的jQuery对象
	height: int, // 散点图的高度
	width: int, // 散点图的宽度
	group: [{ // 散点图中的各个类型，并且赋予其坐标
		x: float,
		y: float,
		label: string,
		color: string
	}]
	clickEvent: function, // 点击事件
	data:[{ // 各个点的坐标数值以及介绍
		x: float,
		y: float,
		info: string
	}],
	meaning: { // 坐标的含义
		x: string,
		y: string,
		xRate: bool,
		yRate: bool
	},
	zones: { // 散点图的四个区域的名称以及含义
		lt: string,
		ltexp: string,
		rt: string,
		rtexp: string,
		lb: string,
		lbexp: string,
		rb: string,
		rbexp: string
	}
}
```

实现的思路如下：
- 初始化坐标轴，计算出```data```中坐标进行平移的向量以及拉伸的系数，使之能够撑满```width```和```height```
- 绘制坐标轴，解释坐标的含义并且画上划分线
- 绘制四个区域
- 对所有的散点进行分类
- 绘制坐标点，通过到类型坐标的距离来决定其颜色深浅和半径大小
- 绘制图例
- 绑定散点的覆盖和点击事件

其中，最为复杂的，之一在于坐标轴的平移与拉伸。在本项目中，我们散点的横坐标与纵坐标都是百分数，也就是-1 ~ 1的区间，没有办法直接在图中转换为像素值，进行绘制。因此我们最先要做的，是将这些百分数的值转换成实际所要绘制的坐标值。在转换之前，我们需要计算一些初始数据：散点横纵坐标各自的最大值与最小值```maxX```，```maxY```，```minX```，```minY```；散点的中心位置坐标```_graphCenterX```， ```_graphCenterY```；实际坐标系的中心位置 ```_centerX```, ```_centerY```。

通过这些值，我们需要算出如下信息：
1. 每一个散点在实际坐标系的位置```(data[index].x - _graphCenterX, data[index].y - _graphCenterY)```
2. 拉伸系数。```_graphScaleX = width / (maxX - minX)```; ```_graphScaleY = height / (maxY - minY)```

然后在计算散点实际绘制的坐标过程中，我们只需要对每一个散点在实际坐标系的位置先进行拉伸（将其乘上 ```_graphScaleX```和 ```_graphScaleY```）,然后按照一个方向向量进行平移（加上 ```_centerX```, ```_centerY```)即可。

之二在于散点的分类和绘制。对于点的分类，我采用的是类knn算法。每一种类型，我们都赋予其一个实际的坐标值```(group[index].x, group[index].y)```，而对于每一个散点，我们计算出他到各个类型的坐标的距离，取其最短，将该散点归类到该类型中。在同一种类型中，我们计算出其中所有的散点到类型坐标的距离，根据距离的长短来决定其颜色深浅以及半径大小，完成最终的绘制。

### 使用说明

至此，在本项目中封装好的类都已经介绍完毕了。使用方法大同小异：

```
var a = new B({
    ... // 根据每一个类传入所需要的参数值
})
a.render()
```

执行上述代码后就能正常使用该类了。

## 后记

NONE

