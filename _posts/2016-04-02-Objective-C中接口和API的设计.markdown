---
layout:     post
title:      "Objective-C中接口和API的设计"
subtitle:   "《Effective Objective-C 2.0》接口与API部分笔记"
date:       2016-04-02 12:00:00
author:     "George"
header-img: "img/post-bg-2015.jpg"
tags:
    - iOS
    - 技术
    - Objective-C
---

首先有一点需要注意，在OC中是没有命名空间这个概念的。也就是说，我们用以区分不同变量的唯一方法就是变量名。所以我们会看到很多NS开头的对象，这些对象是Foundation库的。UI开头的对象是在UIKit库中。CF开头的对象是在CoreFoundation库中。所以我们自定义的库往往都用一些大写字母来开头，以区分不同的变量名。例如AFNetwork。不过，所有两个字母前缀都被苹果所保留了，我们最好以三个字母前缀开头。

在很多的OC类中，有许多不同的初始化方法。但是往往只有一个全能初始化方法(designated initializer)，其他所有初始化方法都是调用了这个全能初始化方法。如果这个类有一个子类，而子类的全能初始化方法名称与父类不同，那么我们必须重写其父类的全能初始化方法。当然，有时候我们不需要父类的全能初始化方法，那么我们重写的时候抛出异常即可。

说说OC中打印的技巧。很多时候我们用NSLog来答应对象，比如：

```
NSLog(@\"%@\", object)
```

但是如果用这种方法来打印一个自定义的类的话，我们得到的信息只有类似于这样的:

```
<SomeClass: 0x123456789ab>
```

如果要打印出我们想要的信息，那么我们必须重写description，这个函数返回一个被打印出的字符串。

我们在写一个类的时候，应当尽量使用不得变对象，只需要在property中加上readonly修饰符，这样我们不会为此生成setter，也就无法修改了。如果我们想在类的实现文件中对其进行修改，我们可以在class-continuation中修改他的修饰符为readwrite，这样我们就只能在类中对其进行修改。如果我们有一个业务逻辑上可变的collection，也不能将其直接公开，而应当是提供相应的方法，对其进行改变。除了属性以外，还有一些方法也是只在类中才能使用，OC没有办法把一个类标注成private的，因此我们需要加上一些前缀来区分他们。常用的可以是一个p加上下划线来进行处理。当然，私有的方法不应该出现在类的接口定义中。

最后来说一下NSCopying这个协议。我们经常在NSString的属性加上copy这个修饰符，那这个修饰符到底有什么作用呢？事实上，在OC中，我们可以把一个可变对象赋给一个不可变的对象，而copy方法会返回一个不可变对象，即NSMutableString返回一个NSString。如果不这样做，那么原来的不可变对象可能会遭到别人修改。同理，mutableCopy方法会返回一个可变对象。如果我们需要对自己的类实现copy方法，我们需要在类中实现copyWithZone:方法，要实现mutableCopy的话，需要实现mutableCopyWithZone方法。

在OC中，还有深拷贝和浅拷贝之分。浅拷贝仅仅拷贝了对象，而其底层的数据是共用一套的。深拷贝与此相反，同时拷贝了一套底层的数据。我们需要知道的是，如果一个不可变对象调用了copy方法，那么这时候是浅拷贝(因为本身和拷贝出来的对象都是不可变的，因此底层数据可以共用一套)。而如果其中之一为可变的，那么就是深拷贝，因为我们并不希望改变了其中一个值之后，另一个值也发生改变(对于不可变的值更是禁忌)。
