<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GeorgeJin</title>
    <description>My personal webpage</description>
    <link>https://gougoumemeda.github.io/</link>
    <atom:link href="https://gougoumemeda.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 30 Jul 2016 00:10:15 +0800</pubDate>
    <lastBuildDate>Sat, 30 Jul 2016 00:10:15 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>鹅厂是个好地方</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“来腾讯实习快两周了，感触颇深。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;放假之前&lt;/h2&gt;

&lt;p&gt;其实给我Offer的也只有两个公司。一个是携程，还有一个就是腾讯了。虽然腾讯把我安排到了深圳，但毕竟是大厂，能进去总觉得有一种自豪感。所以两者之中，我还是毫不犹豫的选择了腾讯。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;section-1&quot;&gt;放假中&lt;/h2&gt;

&lt;p&gt;在去腾讯之前，去了一次欧洲。游玩了德国和荷兰，为时九天。荷兰的夜生活相当丰富，荷兰的法律相当开明，可能这也是uber遵循荷兰法律的原因之一吧。40欧就能看到真人AV秀，你值得拥有。&lt;/p&gt;

&lt;p&gt;应该算是第二次来深圳，上次来的时候还是大一暑假，也是南山，也是腾讯。两年之后故地重游，也就有了一丝亲切感。到住的地方是凌晨两点，因为深圳的暴雨，飞机延误了四个小时。住的地方很简陋，一张桌，一个衣柜，没了。第二天赶紧购置了一批生活用品，买了一张床上桌子，否则真的没有办法写代码。&lt;/p&gt;

&lt;p&gt;13号，周三，正式入职的一天。早上就一直在忙碌着各种手续，在腾大和科兴之间来回穿梭。在科兴吃了一顿午饭，竟然要30元，这让月薪不足3000的我怎么活下去？见到导师大约是下午两点半，高高瘦瘦，非常干净，说话声音很轻，一眼就可以看出来是一个二次元，有着二次元男性透露出的那种宅属性。公司配置的电脑相当给力，i7，960，16G，这个配置完全可以特效全开的玩守望先锋。想到这里，我不禁心里暗喜。&lt;/p&gt;

&lt;p&gt;你以为我就这样可以玩游戏了？公司的网络是不能访问外网的，需要配置各种代理。于是我的守望先锋计划整整延后了两周，终于在公司KM平台上找到了运行的方法。每天中午的午休时间就变成了我的战斗时间。&lt;/p&gt;

&lt;p&gt;导师人相当不错，培养思路非常清晰，第一周我熟悉一下Unity这个平台，然后开发一款游戏出来。我选择的是我大一做过的游戏是男人就坚持二十秒。其实游戏思路很简单，只是我要去慢慢熟悉这个平台。完成之后还没结束，我需要将其优化，通用化，增加他的鲁棒性和可拓展性。&lt;/p&gt;

&lt;p&gt;比如说，生成岩石的过程中，RockController来控制每一个独立的岩石，Pool控制所有岩石的初始化，销毁与复用，RockGenerator来设置每一波岩石的各个参数，比如速度，数量等，而SpawnManager就是真正让一波岩石移动的类。这样的结构用在这个项目上看上去有一点大材小用，但是当项目规模大了，这样的架构就非常有必要。&lt;/p&gt;

&lt;p&gt;腾讯的食堂味道也非常不错，每顿还会有免费的水果。除了价格比较贵，其他真的挑不出什么毛病。如果你加班到晚上八点之后，还会获得一张夜宵券，虽然叫夜宵券，但他是可以用来刷晚饭的，也就是说，免费请你吃一顿第二天的晚餐。&lt;/p&gt;

&lt;p&gt;之前在知乎上看到，如何评价2016年的腾讯。在回答中，大家基本上都是在表扬腾讯。BAT三家中，似乎腾讯已经成为了最出色的一家。来到腾讯之后，深觉腾讯的确是这样一家公司。有时候会抱怨他的收费贵，但是他是一家做实事的公司。你以为只有你们吐槽腾讯吗！每次在KM平台上都会看到腾讯自己人对自己产品的各种抱怨，当然也会有相关的负责人员及时反馈与修复，所以腾讯才能越来越壮大。&lt;/p&gt;

&lt;p&gt;我所在的部门是IEG，互动娱乐事业群，也就是做游戏，娱乐相关的。说来有点惭愧，我现在没有在玩任何一款腾讯系的游戏。有时候会想，腾讯在世界上游戏行业收入第一，那么为什么没有独立研发出现象级的游戏产品呢？我们耳熟能详的英雄联盟，CF都是其他公司开发，腾讯代理或者收购的。近来腾讯也收购了前段时间风靡全球的部落冲突的开发商supercell，但是在收购之后，又出来了Pokemon Go。大家总说腾讯喜欢抄，没错，可能就是因为这样的抄，让腾讯没有办法在游戏行业成为像暴雪那样的信仰公司。腾讯总是会去收购，代理一些成熟的，已经风靡的游戏，而不敢去接触一些未知的领域和挑战（比如AR技术Pokemon Go），可能这就是原因吧。&lt;/p&gt;

&lt;h2 id=&quot;section-2&quot;&gt;放假之后&lt;/h2&gt;

&lt;p&gt;虽然两周时间已经很喜欢腾讯了，但是我还是想回上海，想和大伙儿们一起去网吧开黑，一起吃火锅，一起洗澡。在深圳觉得自己就是一个废人，除了上班就是看剧，除了看剧就是写博文，除了写博文就是打游戏，活生生的变成了葛优。&lt;/p&gt;

</description>
        <pubDate>Mon, 25 Jul 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/07/25/%E9%B9%85%E5%8E%82%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9C%B0%E6%96%B9/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/07/25/%E9%B9%85%E5%8E%82%E6%98%AF%E4%B8%AA%E5%A5%BD%E5%9C%B0%E6%96%B9/</guid>
        
        <category>生活</category>
        
        <category>腾讯</category>
        
        <category>工作</category>
        
        
      </item>
    
      <item>
        <title>告别浮夸，新版博客你好</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;“总觉得自己的审美提高了一大步。”&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;讲真，现在回过头看自己过去的那个个人主页，已经有点不堪入目了。bug相当多，而且操作也不友好，优化也做得很差。这次修改，不仅是想让自己网站变得更加干净，也希望自己能够更加简单一些吧。&lt;/p&gt;

&lt;p&gt;我使用的是&lt;a href=&quot;http://huangxuan.me&quot;&gt;Hux&lt;/a&gt;的网页作为参考，有关于任何技术方面的细节，可以去他的网站看。如果你也想做一个类似的博客，可以去clone他在github上面挂的模板。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;关于我的博客，如果你有任何问题，请联系gougoumemeda@sjtu.edu.cn&lt;/p&gt;

</description>
        <pubDate>Sun, 24 Jul 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/07/24/%E5%91%8A%E5%88%AB%E6%B5%AE%E5%A4%B8-%E6%96%B0%E7%89%88%E5%8D%9A%E5%AE%A2%E4%BD%A0%E5%A5%BD/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/07/24/%E5%91%8A%E5%88%AB%E6%B5%AE%E5%A4%B8-%E6%96%B0%E7%89%88%E5%8D%9A%E5%AE%A2%E4%BD%A0%E5%A5%BD/</guid>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>iOS应用逆向工程</title>
        <description>&lt;p&gt;之前想深入理解一下iOS方面的知识，就看了《iOS应用逆向工程》这本书。不可否认，这本书是我目前为止看到过的有关iOS方面的最精彩的书籍之一了。&lt;/p&gt;

&lt;p&gt;原先对于iOS的了解，无非就是一些苹果公开的Api，以及AppStore等非常官方的东西。这本书讲逆向工程，也就是从一个hacker的角度来看待iOS系统。当然，要越过苹果的重重障碍，必要的一点就是先越狱，为此我也在淘宝上买了一部二手的iPhone4S来作为我的测试机。&lt;/p&gt;

&lt;p&gt;越狱后，突然间iOS系统就变得很透明了，原先不知道的文件结构现在都暴露在我们面前。其实和MacOS的文件结构还是比较类似的，自己随便看看就能大概知道什么文件夹下存放着什么信息。此外接触了一些新的工具，比如Theos，IDA，class-dump等。前者类似于Xcode，是一个开发工具，可以专门用来写Tweak，也就是我们常说的“插件”。后两者才是真正厉害的东西，IDA是一个反汇编工具，class-dump能分析出二进制文件中的头文件。有了这两个东西，理论上任何的二进制文件我们都能知道他的具体实现，就看我们读汇编的功力深不深了。&lt;/p&gt;

&lt;p&gt;之前对于调试工具都不太重视，也不太愿意在程序中打断点。这恰恰是逆向工程的核心之一，打断点是在分析程序的过程中非常好的习惯，在多接触了LLDB之后，发现打断点真的能够带我们慢慢了解一个程序，而不仅仅是停留在UI层面。配合debugserver工具，任何的应用我们都能让他“随时停止”。&lt;/p&gt;

&lt;p&gt;所以，在逆向工程中，流程大概是这样：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;Reveal定位View&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;cycript测试这个View就是我们想要的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;找到这个View的Controller。如果是Button，找到他的响应函数，进入5&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;IDA+LLDB中找到这个Controller中的数据源&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改数据源或者响应函数，实现自己的想法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Theos写成Tweak&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;书上的案例我都跟着做了，挺有意思的。其中“将电子邮件自动标为已读”这个项目中，作者使用AlertView来选择一个电子邮件。我写的时候拓展成了UITableView，这样就可以选择多个电子邮件了。&lt;/p&gt;

&lt;p&gt;可惜的是，除了工具和汇编方面的知识，其他方面的我以后使用的地方估计不多了。当然这本书带给我的乐趣是相当多的，第一次见识到逆向的威力，也看到了iOS不为人知的一面，实在是让人兴奋。&lt;/p&gt;
</description>
        <pubDate>Tue, 31 May 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/05/31/iOS%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/05/31/iOS%E5%BA%94%E7%94%A8%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>逆向</category>
        
        
      </item>
    
      <item>
        <title>SJTULost的一些体会</title>
        <description>&lt;p&gt;最近花了大约一个月的时间来开发这个SJTULost的项目，这个项目其实是我的数据库大作业，主要是一个交大学生使用的失物招领平台，从技术上介绍一下这个项目吧。&lt;/p&gt;

&lt;p&gt;前端，因为之前使用过一次React但是时间比较仓促，没有仔细的去研究过这个框架具体的使用方法。这次使用了React之后也搭配了Flux作为前端的框架。确实，有了Flux之后数据在前端的传递更加清晰，将Action和Store分隔开来的做法也使得代码有更强的可读性和可拓展性。当然，前端数据和后台数据放在了Action中完成，使用Ajax来对后台进行请求，返回的数据都是Json格式的。得到返回数据后再通知Store去更新其前端数据，并且显示在用户面前。&lt;/p&gt;

&lt;p&gt;Action里面主要分为两个部分，一个是UserAction，主要记录用户的操作，比如修改用户信息，登录等。还有一个叫InitializationAction，记录的是其他所有的操作，包括Finding和Found的读取，过滤，更新，查询等。&lt;/p&gt;

&lt;p&gt;Store的东西相对会多一点，数据库中每一个关系对象都会有一个Store，比如Finding，Found，ItemType和Place。同时，针对一些特定的功能我们也提供了其Store，比如Rank，后台将排好序的名字返回给前端，保存在Store中并最后显示。&lt;/p&gt;

&lt;p&gt;后台用的还是Django，一方面比较成熟，另一方面因为我之前也做过Django项目，所以学习成本会低很多。&lt;/p&gt;

&lt;p&gt;数据库的话，我一共建了五个表（不包括多对多关系的第三张表）。分别是Finding，Found，User，ItemType和Place。各个表之间的关系还是比较明确的。将Finding和Found分开也是因为这两者虽然字段很接近，但是其功能是截然不同的。&lt;/p&gt;

&lt;p&gt;接下来说说看这个项目中的一些难点。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;登录。项目中我没有自己设立登录系统，在User表中也是没有username和password这样的字段的。我使用的是交大的&lt;a href=&quot;http://developer.sjtu.edu.cn/wiki/JAccount&quot;&gt;Jaccount&lt;/a&gt;登录系统来进行判断用户的身份，也就是说，这个网站只有交大的同学才能够使用。Jaccount授权系统使用的是OAuth2，因为之前没有熟悉过，所以在开发的时候还是遇到了一些问题的，比如authorization和access token的两个url的回调函数必须是一致的，否则没有权限获取access token。得到用户信息之后，判断用户是否存在于数据库，如果不存在就创建一个新的元组。同时将这个用户在User表中的id保存在session里，有效期为两周，因此在两周内用户是不需要登录的。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;搜索。问题在于用户输入多个关键字时，我们应该怎么看待这些关键字的关系，是同时满足还是至少满足一个。因此我将与运算和或运算都加入到搜索系统里面，方便用户的查询。在后台使用queryset的field_contain参数，就能够从数据库里获取想要的信息。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分页。分页的问题在于，我们除了需要获取那些部分的数据之外，还要获得所有数据的总数，这样才能知道什么时候用户是没有办法点击下一页的。我现在的实现中还存在着一个问题，用户每一次点击一页，相当于是重新计算了一遍再把数据返回前台。我理想的结果是，用户进入第一页之后，后台先返回第一页，然后在将后面一部分的页面读取出来缓存起来，这样如果用户点击下一页就不需要重新计算了，可以直接将数据返回前端。如果用户点击到了没有缓存过的一页，则再计算一遍。这样我们实际是利用用户浏览的时间才读取后面的内容，减少网页响应时间。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选取时间。在网上找过一些时间的插件，但是都是用jQuery实现的，React版本的时间插件并不流行。最后选择了&lt;a href=&quot;https://github.com/YouCanBookMe/react-datetime&quot;&gt;react-datetime&lt;/a&gt;这个插件，能够和我的项目兼容。其中有一些props可以传递，包括dateFormat，timeFormat之类，都是可以在moment.js的网站上找到相应的字符格式。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;上传图片。抱歉，我实在没找到合适的React的上传文件的插件，因此还是用jQuery写成的&lt;a href=&quot;https://github.com/blueimp/jQuery-File-Upload&quot;&gt;jQuery-File-Upload&lt;/a&gt;插件。不过我将上传的动作放在了Action里，使得除了Action文件以外的地方都不会出现$这个符号。将图片传递给后台之后，使用qiniu的Python SDK将其上传到七牛云。最后把照片的url返回给前端，实时预览。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;关于这个项目的大概就是这些，如果有问题的话可以联系我。&lt;/p&gt;

&lt;p&gt;项目目前还没有服务器，有没有老司机推荐一个能跑python的，便宜的，免备案的服务器？&lt;/p&gt;
</description>
        <pubDate>Sat, 21 May 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/05/21/SJTULost%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%93%E4%BC%9A/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/05/21/SJTULost%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BD%93%E4%BC%9A/</guid>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        <category>Python</category>
        
        <category>Web</category>
        
        
      </item>
    
      <item>
        <title>关于Django, React和Flux的一些思考</title>
        <description>&lt;p&gt;最近在用Django作为后端写一个SJTU Lost的Web应用，主要是一个失物招领的平台吧，交大学生如果丢了什么东西可以发布过去，如果捡到什么东西也可以在上面贴出来。&lt;/p&gt;

&lt;p&gt;然而我在做的过程中遇到了不少的问题。&lt;/p&gt;

&lt;p&gt;首先，Django这个后端框架我还是比较熟悉的，外接了MySQL数据库之后，后台并没有遇到太大的问题。然而在选择前端的框架是我纠结了很久：是使用比较传统简单的jQuery还是比较新但是上手比较困难的React？最终我还是选择了React，算是给自己的一个挑战，也是让我接触新知识的一个很好的机会。毕竟以后web component是一种趋势，而jQuery终究会过时。&lt;/p&gt;

&lt;p&gt;实际上，ReactJS只是一个View的框架，他能很好的帮助我们创建组件视图，但是并不能够很优雅的保存一些状态与数据，在处理一些交互动作时也显得略微笨重。在React这个前端技术栈中，现在比较流行的是React+Flux+ReactRouter。&lt;/p&gt;

&lt;p&gt;Flux实际上提供了单向数据流的传递方案，Action，Dispatcher和Store能够很好的解决React中没办法保存状态数据的问题。&lt;/p&gt;

&lt;p&gt;大概流程是，用户在View上点击一个按钮，产生一个Action，Action会调动Dispatcher来分发相应的数据，Store中数据的改变又会让View进行更新，最终显示用户想要的内容在页面上。&lt;/p&gt;

&lt;p&gt;ReactRouter我并没有使用，简单来说就是定义一些url和相应显示的component。因为Django自带有router功能，所以我直接把这部分抛弃了。&lt;/p&gt;

&lt;p&gt;要安装Flux和ReactJS的话最好还是使用npm，所以引入了一部分nodejs的知识，其实也就是很简单的require一个模块方面的内容，但是作为一个从来没有用过nodejs的人，我发现浏览器没有办法识别出require函数。。。搜索资料过后，发现要先用browserify/webpack将其打包，并且用执行的工具将代码编译成浏览器能识别的js文件。前者是比较传统的工具，缺点是很多东西不支持，比如jsx。后者可以自己定制想要的效果，保存在webpack.config.js文件中，因此最终选择了后者。ES6语法转换成ES5语法直接用Babel就好了，jsx文件也有对应的jsx-loader！&lt;/p&gt;

&lt;p&gt;好，介绍完了技术背景之后，我来说一下我遇到的问题和一些思考。&lt;/p&gt;

&lt;p&gt;如何在整个浏览器生命周期中共享一份Store/Action/Dispatcher?&lt;/p&gt;

&lt;p&gt;其实这个问题非常的普遍。我们第一次进入一个页面后，将一部分信息保存在Store里面。如果我们导航到这个页面的一个子页面，我们还是希望能够继续得到这部分信息的。如果重新跟后台请求，那会再一次产生网络负担，而如果这部分信息能一直保存在Store中的话，就节约了这部分开销，相当于缓存在浏览器中。&lt;/p&gt;

&lt;p&gt;但是！我并没有找到合适的解决方案，目前进入不同的页面还是会产生一个新的Store实例，然后从后台得到相应的数据。我觉得Flux设计的理念是和我想的一样的，但是我没有办法在Django框架下解决这个问题（除非我们写单页应用，即只有一个url，那我们在一个js文件中只需要require一次，相应的Store/Action/Dispatcher肯定也只有一个了）。Django的路由决定了视图，因此切换到不同的url时，视图会被加载，视图中的js文件也会被加载（即使是相同的视图也会重新加载一次，导致了新的实例的产生）。当然我知道现在很多跨url保存一些数据（比如购物车里的东西）比较常见的做法是使用cookie，之后如果时间充足应该也会考虑这样的做法（其实可以用session来存放，但是那样我就感觉Flux没啥存在的价值。。。）&lt;/p&gt;

&lt;p&gt;现在有一个导航栏，如何保证在所有页面中我们使用的是一个导航栏(减少加载)?&lt;/p&gt;

&lt;p&gt;这个问题本质和问题1是一样的，每一次访问一个Django的新路由，都会加载或者重新加载一个视图，只要导航在这个视图中，就会重新加载。&lt;/p&gt;

&lt;p&gt;如果要解决这个问题，第一是可以考虑用Ajax，但是这样的话就只能使用一个url了。&lt;/p&gt;

&lt;p&gt;还有一种方法是使用Pjax，这是pushState+Ajax，可以在改变url的同时异步加载网页一部分内容。事实上在之前是有一个Django-Pjax的，但是作者已经很久没有更新了，似乎已经不支持现有的版本了。如果之后有时间的话也会去尝试一下这个库。&lt;/p&gt;

&lt;p&gt;现在还没有解决这个问题，也希望大家能够帮我想想办法。&lt;/p&gt;

&lt;p&gt;大概就是这样，明天继续填坑。&lt;/p&gt;
</description>
        <pubDate>Mon, 25 Apr 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/04/25/%E5%85%B3%E4%BA%8EDjango,-React%E5%92%8CFlux%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/04/25/%E5%85%B3%E4%BA%8EDjango,-React%E5%92%8CFlux%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83/</guid>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        <category>Python</category>
        
        <category>Web</category>
        
        
      </item>
    
      <item>
        <title>Objective-C中的系统框架</title>
        <description>&lt;p&gt;iOS开发中有两个最重要的系统框架: Foundation和CoreFoundation，前者定义了OC对象，后者是C语言的API和数据结构。对于Foundation中的每一个OC对象，我们都有一个对应的CoreFoundation数据结构，使用__bridge可以进行无缝桥接：&lt;/p&gt;

&lt;p&gt;__bridge: ARC仍然具备这个OC对象的所有权&lt;/p&gt;

&lt;p&gt;__bridge_retained: ARC交出这个OC对象的所有权，我们需要手动Release&lt;/p&gt;

&lt;p&gt;__bridge_transfer: ARC获得对象的所有权&lt;/p&gt;

&lt;p&gt;在OC中，我们遍历一个Collection有以下几种方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;常规的for循环，和C语言一样&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;NSEnumerator来遍历：nextObject方法来返回枚举里的下个对象，最后一个对象则返回nil&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;快速遍历：for…in&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;块遍历：enumerateObjectsUsingBlock, enumerateKeysAndObjectsUsingBlock&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;块遍历可以提供对象，下标和指向是否终止的布尔值的指针。&lt;/p&gt;

&lt;p&gt;在进行网络请求下载资源的时候，我们通常会把内容缓存下来。这时候应该采用NSCache。NSCache会在系统资源将要耗尽的时候，自动删减缓存。我们可以设置NSCache的对象的上线和总成本，来定义缓存删减其中对象的时机。&lt;/p&gt;

&lt;p&gt;initialize和load方法是OC对象两个比较特殊的初始化方法。前者在第一次使用对象的时候调用，后者在APP启动的时候调用。需要注意的是，这两个方法都是阻塞的，因此我们不能放太多的操作在这两个方法之中。在load方法中我们不能调用其他类中的方法，因为初始化的顺序和时机是程序员不能确定的。&lt;/p&gt;
</description>
        <pubDate>Wed, 13 Apr 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/04/13/Objective-C%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/04/13/Objective-C%E4%B8%AD%E7%9A%84%E7%B3%BB%E7%BB%9F%E6%A1%86%E6%9E%B6/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
      <item>
        <title>Objective-C中的协议和分类</title>
        <description>&lt;p&gt;delegate也是iOS编程中的一个重点，他定义了一套接口，如果一个对象想接受另一个对象的委托，则需要遵从此接口，以便成为其委托对象。这个委托的意思，实际上就是把函数的实现写在另一个类中，这个函数可以使用那个类的方法和数据成员。看上去就像是这个类帮别人做了写事情，成为委托的对象。委托的协议用@protocal来定义，在存放委托对象的类中，可以这么写：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@property&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nonatomic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;id&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeProtocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;delegate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们必须用weak修饰符来避免循环引用。上述代码的id指向遵循这个协议的类，表示我们不关心这个类具体是什么，我们只注意到这个类遵循了这个协议。当然，对于可选的方法，我们在前面加上@optional即可。&lt;/p&gt;

&lt;p&gt;下面来说说分类这个东西。OC中的分类对应swift就是其extension。我们可以通过分类把类实现代码按照逻辑分散到几个文件中:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nl&quot;&gt;AboutSomething&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;分类中的方法是直接添加在类里面的，就好比是这个类的固有方法，因此会有覆写的可能性。需要注意的一点是，我们不要在分类中声明属性，因为在分类中是不能添加实例变量的。那不代表不能声明属性，通过@dynamic关键字，或者关联对象，都能够解决这个问题。但是保险起见，还是不要声明属性。当然，不是说所有的分类都不能，有一种分类叫做class-continuation就是例外，他有如下的特点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;必须定义在其所接续的那个类的实现文件里&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;唯一能够声明实例变量的分类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分类没有名字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;分类中的所有属性和方法都是隐藏的，只能在本类中使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以修改某属性的读写性，只读的属性可以在此分类中扩展为可读写&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;比如这样：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，协议也可以隐藏在class-continuation中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SomeClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SomeProtocal&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;...&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Mon, 04 Apr 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/04/04/Objective-C%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%88%86%E7%B1%BB/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/04/04/Objective-C%E4%B8%AD%E7%9A%84%E5%8D%8F%E8%AE%AE%E5%92%8C%E5%88%86%E7%B1%BB/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
      <item>
        <title>Objective-C中接口和API的设计</title>
        <description>&lt;p&gt;首先有一点需要注意，在OC中是没有命名空间这个概念的。也就是说，我们用以区分不同变量的唯一方法就是变量名。所以我们会看到很多NS开头的对象，这些对象是Foundation库的。UI开头的对象是在UIKit库中。CF开头的对象是在CoreFoundation库中。所以我们自定义的库往往都用一些大写字母来开头，以区分不同的变量名。例如AFNetwork。不过，所有两个字母前缀都被苹果所保留了，我们最好以三个字母前缀开头。&lt;/p&gt;

&lt;p&gt;在很多的OC类中，有许多不同的初始化方法。但是往往只有一个全能初始化方法(designated initializer)，其他所有初始化方法都是调用了这个全能初始化方法。如果这个类有一个子类，而子类的全能初始化方法名称与父类不同，那么我们必须重写其父类的全能初始化方法。当然，有时候我们不需要父类的全能初始化方法，那么我们重写的时候抛出异常即可。&lt;/p&gt;

&lt;p&gt;说说OC中打印的技巧。很多时候我们用NSLog来答应对象，比如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSLog(@\&quot;%@\&quot;, object)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但是如果用这种方法来打印一个自定义的类的话，我们得到的信息只有类似于这样的:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;SomeClass: 0x123456789ab&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果要打印出我们想要的信息，那么我们必须重写description，这个函数返回一个被打印出的字符串。&lt;/p&gt;

&lt;p&gt;我们在写一个类的时候，应当尽量使用不得变对象，只需要在property中加上readonly修饰符，这样我们不会为此生成setter，也就无法修改了。如果我们想在类的实现文件中对其进行修改，我们可以在class-continuation中修改他的修饰符为readwrite，这样我们就只能在类中对其进行修改。如果我们有一个业务逻辑上可变的collection，也不能将其直接公开，而应当是提供相应的方法，对其进行改变。除了属性以外，还有一些方法也是只在类中才能使用，OC没有办法把一个类标注成private的，因此我们需要加上一些前缀来区分他们。常用的可以是一个p加上下划线来进行处理。当然，私有的方法不应该出现在类的接口定义中。&lt;/p&gt;

&lt;p&gt;最后来说一下NSCopying这个协议。我们经常在NSString的属性加上copy这个修饰符，那这个修饰符到底有什么作用呢？事实上，在OC中，我们可以把一个可变对象赋给一个不可变的对象，而copy方法会返回一个不可变对象，即NSMutableString返回一个NSString。如果不这样做，那么原来的不可变对象可能会遭到别人修改。同理，mutableCopy方法会返回一个可变对象。如果我们需要对自己的类实现copy方法，我们需要在类中实现copyWithZone:方法，要实现mutableCopy的话，需要实现mutableCopyWithZone方法。&lt;/p&gt;

&lt;p&gt;在OC中，还有深拷贝和浅拷贝之分。浅拷贝仅仅拷贝了对象，而其底层的数据是共用一套的。深拷贝与此相反，同时拷贝了一套底层的数据。我们需要知道的是，如果一个不可变对象调用了copy方法，那么这时候是浅拷贝(因为本身和拷贝出来的对象都是不可变的，因此底层数据可以共用一套)。而如果其中之一为可变的，那么就是深拷贝，因为我们并不希望改变了其中一个值之后，另一个值也发生改变(对于不可变的值更是禁忌)。&lt;/p&gt;
</description>
        <pubDate>Sat, 02 Apr 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/04/02/Objective-C%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8CAPI%E7%9A%84%E8%AE%BE%E8%AE%A1/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/04/02/Objective-C%E4%B8%AD%E6%8E%A5%E5%8F%A3%E5%92%8CAPI%E7%9A%84%E8%AE%BE%E8%AE%A1/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
      <item>
        <title>Objective-C中的消息</title>
        <description>&lt;p&gt;我们先来介绍一下OC中属性的用法。属性就是我们在实际工程中运用的最多的形式，以@property开头。用属性有什么好处呢？简单来说，属性有利于我们对内存的管理，系统会自动生成一套setter和getter来处理对属性的读取和写入操作，同时满足用户指定的strong，week等修饰符。当然，只要在属性头加上@dynamic，系统就不会自动去生成setter和getter。同时，系统会为每一个属性增加一个实例的变量，在属性名前加上下划线作为实例变量的名字。实际上，系统的setter和getter都是对其实例变量进行操作。我们可以理解成属性把实例变量封装了起来。需要说明的是，我们在一个对象/类中，最好直接访问实例变量。如果用的是属性，那么会经过setter和getter方法，这是通过OC的方法派发来完成的，所以效率会比较低，而实例变量会绕过内存管理的语义，在速度上有优势。&lt;/p&gt;

&lt;p&gt;接下来说明一下对象等同性。在OC中，==比较的是指针，isEqual(或其类似方法)比较的是其内容。这个应该很好理解，我们应当使用isEqual。当然，我们可以对自己写的类写一个isEqual方法。&lt;/p&gt;

&lt;p&gt;如果我们想临时给一个类增加一个变量，有什么好用的方法呢？OC给我们提供了一种叫做关联对象的方法。有如下函数：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void objc_setAssociatedObject(id object, void* key, id value, objc_AssociationPolicy policy)
id objc_getAssociatedObject(id object, void* key)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以把关联对象想想成一个字典，需要存放时就增加一个键值对，取出增加的东西时也可以根据键进行选择。但是，此方法慎用，因为滥用的话我们会对一个对象失去可控性。&lt;/p&gt;

&lt;p&gt;我们都知道，OC是一种动态语言，对于一些方法的调用，都是在运行时才去使用。这种方法叫做传递消息，而传递消息最关键的方法就是objc_msgSend。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;id returnVal = objc_msgSend(someObject, @selector(msg:), parameter)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，someObject为消息的接受者(调用函数方)， msg为选择子(函数名)。对于每一个类，我们有一个快速的映射表，如果我们第一次发送一个消息成功后，我们会把匹配的方法名和方法实现放在这个表中作为缓存。那么如果我们找不到一个方法呢？这时候我们就会调用OC的消息转发，具体来说，有三步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;寻找是否有新增加的选择子。这个方法要求我们提前写好代码，等着运行的时候动态插在类里面。常见于@dynamic属性。寻找选择子时，会调用的方法为:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;+ (Bool)resolveInstanceMethod: (SEL)selector
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;selector即为我们所没有找到的选择子。class_addMethod方法会为类增加一个方法实现，而这个实现的新方法名就是我们没有找到的选择子。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;寻找备援接受者，这限于在对象内的其他对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;完整的消息转发，也就是改变调用目标。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;后两个在开发中其实非常的少见。&lt;/p&gt;

&lt;p&gt;接下来要介绍一个黑科技，叫做方法调配Method Swizzling。由于OC的方法调用是在运行时才确定的，因此我们可以在运行时替换方法的实现。
替换方法实现的方法为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void method_exchangeImplementations(Method m1, Method m2)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而根据方法名，得到其实现的方法为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Method class_getInstanceMethod(Class aClass, SEL aSelector)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们只需要根据方法名，取出其实现然后交换就好啦！&lt;/p&gt;

&lt;p&gt;最后，介绍一下OC中的类。对于一个id类型的实例，其本质为一个struct：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef struct objc_object {
	Class isa;
} *id;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;isa指向其所属的类。而对于一个类，其也为一个struct，保存了一些类的数据。在这个struct中，也有一个Class类型的isa，指向这个类的元类。这个元类保存了这个类的一些元数据。而这个struct的super_class指针指向了这个类的父类。那么我们需要查询一个id实例的类型时，可以用如下方法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;isMemberOfClass，查询实例是否为某个类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;isKindOfClass，查询实例是否为一个类或其子类&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;当然，在比较类型时，我们可以用==运算符，因为每一个类在OC中都是单例的，只有一个类对象，也就没有地址不同这样的说法了。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ([object class] == [SomeClass class]) {
	...
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;关于OC的语言特性，其实还有很多，但是其消息和动态的特性是最为关键的。&lt;/p&gt;

</description>
        <pubDate>Tue, 22 Mar 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/03/22/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/03/22/Objective-C%E4%B8%AD%E7%9A%84%E6%B6%88%E6%81%AF/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
      <item>
        <title>Objective-C语言相关</title>
        <description>&lt;p&gt;最近正好在看&lt;em&gt;《Effective Objective-C 2.0》&lt;/em&gt;，简单记录一下每一章节的内容吧，也算是复习了一下。&lt;/p&gt;

&lt;p&gt;那首先我们从语言本身开始说起。Objective-C是使用消息结构而非函数调用的，因此其运行时所执行的代码是由运行的环境来决定，而并非由编译器决定。这样的特性使得Objective-C非常之灵活，因为运行时确定，所以我们可以在写代码的时候展现一些黑科技，比如说运行时的代码替换，Swizzling等。相比而言Swift就更加严谨了，现在常见的一些运行时效果也是通过Objective-C的那一套来实现的。因为Objective-C的这样的特性，因此所有的Foundation中的对象都是保存在堆上而不是栈上，所以我们写代码的时候都使用指针，如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *someString = @\&quot;the string\&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，非Foundation对象，例如CGRect等，都是保存在栈上的。&lt;/p&gt;

&lt;p&gt;本书给我们的第一条建议是“在类的头文件中尽量少引入其他头文件”。道理很简单，头文件a中引入了头文件b，相当于把头文件b的接口信息都暴露给了头文件a，这些信息是无用的。写代码的时候我们要确保其低耦合，因此这么做是非常值得的。那如果我们要使用b中的某个类呢？这时候可以用向前声明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@class SomeClass;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们可以直接使用类名，而把头文件的引入放在实现文件中了。除此之外，在头文件中引入其他头文件也容易产生循环引用，这与内存管理中的循环引用是类似的，不再重复了。&lt;/p&gt;

&lt;p&gt;关于对象，我们需要多用字面量语法，就像我们平时在c++，swift中做的那样。不同的是，我们需要把字面量转换成一个Foundation对象，只需要在字面量前加上@就可以了。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSNumber *someNum = [NSNumber numberWithInt: 1];
NSNumber *someNum = @1;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面两句话是等效的。所有的Foundation对象都可以这么定义，不过有几点需要注意：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;不能出现nil&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;字典与数组中的元素/键值必须都是Foundation对象&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;用字面量创建出的对象都是不可变的&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;此外，很多人喜欢用#define定义宏来表示某些常量，其实在OC中，完全可以用static const来取代。在编译器的处理上说，两者几乎没有区别，而常量增加了一个类型的信息，对于程序员更加友好。如果要定义一个全局的常量，可以使用extern关键字，头文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extern NSString *const someStr;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现文件中：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;NSString *const someStr = @\&quot;fuck\&quot;;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，聊一下枚举。我们可以使用enum来定义一个枚举类型，枚举类型的默认值也可以指定，因此我们可以将不同的值进行或运算，产生某种选项的效果。但是OC给我们提供了两个更加优雅的宏来定义枚举和选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;typedef NS_ENUM(NSUIngeter, ConnectionState) {
	Connected,
	NotConnected,
};
typedef NS_OPTION(NSUIngeter, PermittedDirection) {
	Left,
	Right,
	Up,
	Down,
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从名字就可以看出这两个宏是表示什么意思了吧，宏的第一个参数表示底层的存储类型，第二个参数表示枚举/选项类型的名字。注意一点，我们在switch语句中，如果判断的是枚举类型，则不要加default，否则如果之后新增一种情况的话，很容易增加case语句，编译器也不会给我们任何的警告。&lt;/p&gt;
</description>
        <pubDate>Tue, 08 Mar 2016 20:00:00 +0800</pubDate>
        <link>https://gougoumemeda.github.io/2016/03/08/Objective-C%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/03/08/Objective-C%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/</guid>
        
        <category>iOS</category>
        
        <category>技术</category>
        
        <category>Objective-C</category>
        
        
      </item>
    
  </channel>
</rss>
