<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>GeorgeJin</title>
    <description>My personal webpage</description>
    <link>https://gougoumemeda.github.io/</link>
    <atom:link href="https://gougoumemeda.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Sat, 23 Jun 2018 09:17:53 +0000</pubDate>
    <lastBuildDate>Sat, 23 Jun 2018 09:17:53 +0000</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>移动端模拟Calendar</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;最近在公司因为主要是做mobile的开发工作，而公司本身mobile的组件又非常的匮乏，所以自己制作的组件就数量慢慢多起来了。上次是介绍了一个data-picker，来模拟iOS端UIDataPickerView的行为。这里是实现了一个calendar，这个在iOS或者安卓系统本身的控件中是没有的，所以也没有什么模仿的一说，就是项目需要所以就做了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;现在就来介绍一下这个calendar的实现步骤。其实还是比较简单的相对于上一篇data-picker来说。具体的实现一共分成三步：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;绘制日历&lt;/li&gt;
  &lt;li&gt;滑动操作&lt;/li&gt;
  &lt;li&gt;点击事件&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;我们一步一步介绍具体的操作。&lt;/p&gt;

&lt;h4 id=&quot;section-2&quot;&gt;绘制日历&lt;/h4&gt;

&lt;p&gt;这部分其实没有什么难度，就是几个循环遍历一下就可以。不过有几个变量值得注意一下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var numberOfDays = this.getNumberOfDaysOfMonth_(year, month);
var firstDayOfMonth = this.getFirstDayOfMonth_(year, month);
var numberOfWeeks = this.getNumberOfWeeksOfMonth_(year, month);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一个表示这个月有多少天，实现如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * @private
 * @param {number} year
 * @param {number} month
 * @return {number}
 */
Calendar.prototype.getNumberOfDaysOfMonth_ = function(year, month) {
  return new goog.date.Date(year, month, 1).getNumberOfDaysInMonth();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个函数没有什么要自己计算的部分，调用Google Closure本身的API就可以啦。&lt;/p&gt;

&lt;p&gt;第二个变量表示这个月的第一天是星期几，实现如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * @private
 * @param {number} year
 * @param {number} month
 * @return {number}
 */
Calendar.prototype.getFirstDayOfMonth_ = function(year, month) {
  return new goog.date.Date(year, month, 1).getDay();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实也非常好理解，构造一个这个月第一天的Date变量，获取星期几就可以啦。&lt;/p&gt;

&lt;p&gt;最后一个变量表示这个月有几周，实现如下&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
 * @private
 * @param {number} year
 * @param {number} month
 * @return {number}
 */
Calendar.prototype.getNumberOfWeeksOfMonth_ = function(year, month) {
  var numberOfDays = this.getNumberOfDaysOfMonth_(year, month);
  var firstDayOfMonth = this.getFirstDayOfMonth_(year, month);
  var totalDays = numberOfDays + firstDayOfMonth;
  if (totalDays % 7 === 0) return totalDays / 7;
  else return Math.floor((numberOfDays + firstDayOfMonth) / 7) + 1;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们最终绘制日历的时候，会先从周开始遍历，第三个变量就是控制周遍历的次数。在每一个周遍历中，进行日期的遍历。第一个变量来决定最后一周的日期到哪里结束，而第二个变量来决定第一周的日期从周几开始。所以说这三个变量非常的关键了。其他的绘制过程应该没有什么难度，只要注意如果是当天的话要增加一些样式；如果是选中的日期的话样式要变成什么样就可以了。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;滑动操作&lt;/h4&gt;

&lt;p&gt;这里的滑动操作我们使用了framework7框架中的&lt;a href=&quot;https://framework7.io/docs/swiper.html&quot;&gt;swiper&lt;/a&gt;。首先需要在xml里面添加相应的元素，这里就不多介绍了，主要解释一下js中的操作。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var swiperParams = {
  width: goog.style.getSize(this.getCalendarSwiperWrapper_()).width,
  autoHeight: true
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是，在初始化的时候，我们制定了width值。这是因为，一开始的时候这个swiper是隐藏的，在doc中说到，如果默认隐藏的话，我们需要手动指定width，并且不会有自适应。既然要手动指定width，那么我们就要通过js来获取包它的wrapper的宽度。那么问题又来了，这个初始化的过程我们没有办法确定是在CSS被应用之前还是应用之后。经过测试我们也发现，大多数情况下直接得到wrapper的宽度是0。所以我们需要等这个wrapper的CSS宽度被引用到了元素上之后，在去获取它的宽度。这里就需要Google Closure提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;ConditionalDelay&lt;/code&gt;了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var getCalendarWidthDelay = new goog.async.ConditionalDelay(this.checkCalendarStyleAvailable_, this);
getCalendarWidthDelay.onSuccess = function() {};
getCalendarWidthDelay.start(Calendar.CONST_.TEST_INTERVAL, Calendar.CONST_.TEST_TIMEOUT);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;简单来说，就是每隔一段时间去执行一个函数，这个函数会返回一个boolean。如果true则执行onSuccess。同时会有一个timeout，经过多久之后都不为true的话就放弃。&lt;/p&gt;

&lt;p&gt;初始化swiper结束之后，我们把当前月份，当前月份前后的两个月份同时作为slide加入到这个swiper中。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.swiper_.appendSlide([lastMonthData, currentMonthData, nextMonthData]);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同时，在滑动结束后触发的回调事件中，我们需要规定，如果当前slide是最后一张slide，我们就去load下一月的数据并加入到swiper中。如果是第一张则load再上一个月的数据加进去。这样做用户就不会察觉到实际上我们月份是动态添加进去的，看上去就像是一个能无限滑动的calendar。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if (this.swiper_.activeIndex === 0) {
  this.swiper_.prependSlide(this.getMonthDataElement_(this.getLastMonth_().year, this.getLastMonth_().month));
} else if (this.swiper_.activeIndex === this.swiper_.slides.length - 1) {
  this.swiper_.appendSlide(this.getMonthDataElement_(this.getNextMonth_().year, this.getNextMonth_().month));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-4&quot;&gt;点击事件&lt;/h4&gt;

&lt;p&gt;这个没有什么难度的，点下后获取年月日，同时把这个日期加上选中的样式，清除其他日期上的样式即可。&lt;/p&gt;

&lt;p&gt;有一点需要说的是，我们增加了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;selectableDateRange_&lt;/code&gt;来表示可以选择的日期范围。如果超出了这个范围，那么点上去也不会有什么反应。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;后文&lt;/h2&gt;

&lt;p&gt;没什么想说的谢谢。&lt;/p&gt;

</description>
        <pubDate>Thu, 17 May 2018 23:55:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2018/05/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A8%A1%E6%8B%9FCalendar/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2018/05/17/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E6%A8%A1%E6%8B%9FCalendar/</guid>
        
        <category>Works Applications</category>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>用JS自制UIPickerView</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;这个UIPickerView其实制作的难度还是相当之大的，主要是利用到了一些数学方面的知识和需要考虑性能方面的问题。下面我们就一步一步来讲我的思路和如何去实现的。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h4 id=&quot;section-2&quot;&gt;整体结构&lt;/h4&gt;

&lt;p&gt;首先我们要划分清楚，这个data-picker是一个单独的组件还是由几个小组件构成。这里因为在手机上可能会有几个不同的独立的滚轮，所以我们把一个data-picker拆分成多个不同的data-picker-column。那么所有的滚动实现的细节都在data-picker-column中实现，我们现在来具体思考一下这个column需要哪些操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;建模，把3D模型投射到2D平面中&lt;/li&gt;
  &lt;li&gt;滑动时的行为&lt;/li&gt;
  &lt;li&gt;滑动结束后惯性行为&lt;/li&gt;
  &lt;li&gt;滑动速度小于某值时自动滚动到最近的item&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;大概正常的column实现的步骤就是上述几个。这个其实也很好想，实际在手机上使用时看看干了哪些事就知道了。但是这里我们多增加一个“规范化”的步骤。什么意思呢，实际上我们左右的数学计算都是使用double类型的，而double类型在计算机中会有一部分的精度损失，最终导致在界面上会有微小的位置偏移。所以我们在滚动完之后重新计算一次所有item应该在的位置，然后直接将他们移动过去。这部分时候也会解释。&lt;/p&gt;

&lt;h4 id=&quot;section-3&quot;&gt;建模&lt;/h4&gt;
&lt;p&gt;建模过程并不难，首先我们要确定在组件中需要哪些成员变量。实际上我们所看到的column是由“可见item”组成的，仅仅是180°的视角。而那些不可见的item，会被隐藏起来，具体怎么隐藏可以根据不同的开发者自己设定，但是这部分不可见的，应当在某些条件下（滚动的时候）能够出现在屏幕中，而那些可见的item也能够隐藏起来。&lt;/p&gt;

&lt;p&gt;现在我们来想一下item应该有哪些要素，首先是dom元素，然后是当前item位置的角度，这里我们规定y负方向为0°，z正方向为90°。此外还需要给每一个item增加一个id和这个item的值。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.shownItems_.push({
    &#39;id&#39;: index,
    &#39;currentDegree&#39;: itemDegree,
    &#39;item&#39;: $item,
    &#39;value&#39;: v
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在实际滚动的过程中，真正改变的只有每一个item的&lt;code class=&quot;highlighter-rouge&quot;&gt;currentDegree&lt;/code&gt;。这里我们规定，如果一个item是不可见的，那么他的&lt;code class=&quot;highlighter-rouge&quot;&gt;currentDegree&lt;/code&gt;就是0。也就是在滚轮的最上面。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;this.hiddenItems_.push({
    &#39;id&#39;: index,
    &#39;currentDegree&#39;: 0,
    &#39;item&#39;: $item,
    &#39;value&#39;: v
});
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果我们知道了item当前的&lt;code class=&quot;highlighter-rouge&quot;&gt;currentDegree&lt;/code&gt;，规定了整个column的半径大小，就能够通过数学三角公式计算出这个item的位置。同时补充一点，为了计算方便，这里我们规定相邻的item的间隔为30°。除了位置以外，本身item也需要绕着屏幕x轴进行一定的旋转，这样做的话会使得文字看上去是贴在这个column上面的，目前手机实现的picker也都是如此。最后，我们需要给所有的item规定opacity。当前选中的item的opacity为1，隐藏的为0，然后其他的根据&lt;code class=&quot;highlighter-rouge&quot;&gt;currentDegree&lt;/code&gt;依次计算得到。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* @private
* @param {Element} item
* @param {Number} degree
*/
Column.prototype.setShownItemStyle_ = function(item, degree) {
    var newPosY = Column.Const_.COLUMN_HEIGHT / 2 - Column.Const_.RADIUS * Math.cos(goog.math.toRadians(degree)) -
        Column.Const_.ITEM_HEIGHT / 2;
    var opacity = this.getOpacityByDegree_(degree);
    var rotate = Column.Const_.DEGREE_90 - degree;
    goog.style.setStyle(item, {
        &#39;top&#39;: newPosY + &#39;px&#39;,
        &#39;opacity&#39;: opacity,
        &#39;transform&#39;: &#39;rotateX(&#39; + rotate + &#39;deg) translateX(-50%)&#39;,
        &#39;-ms-transform&#39;: &#39;rotateX(&#39; + rotate + &#39;deg) translateX(-50%)&#39;,
        &#39;-moz-transform&#39;: &#39;rotateX(&#39; + rotate + &#39;deg) translateX(-50%)&#39;,
        &#39;-webkit-transform&#39;: &#39;rotateX(&#39; + rotate + &#39;deg) translateX(-50%)&#39;,
        &#39;-o-transform&#39;: &#39;rotateX(&#39; + rotate + &#39;deg) translateX(-50%)&#39;
    });
};

/**
* @private
* @param {Number} degree
* @return {Number}
*/
Column.prototype.getOpacityByDegree_ = function(degree) {
    var opacity = 1;
    if (degree &amp;lt;= Column.Const_.DEGREE_90) {
        opacity = 1 - 1 / Column.Const_.DEGREE_90 * (Column.Const_.DEGREE_90 - degree);
    } else if (degree &amp;gt; Column.Const_.DEGREE_90 &amp;amp;&amp;amp; degree &amp;lt; Column.Const_.DEGREE_180) {
        opacity = 1 - 1 / Column.Const_.DEGREE_90 * (degree - Column.Const_.DEGREE_90);
    } else {
        opacity = 0;
    }
    return opacity;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;到这里我们就已经可以把模型建立起来了，可以在屏幕上画出一个静止的column来。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;滑动时的行为&lt;/h4&gt;

&lt;p&gt;我们把整个滑动时的行为分解成三个部分，分别对应浏览器的 &lt;code class=&quot;highlighter-rouge&quot;&gt;touchstart&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;touchmove&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;touchend&lt;/code&gt; 事件。&lt;/p&gt;

&lt;p&gt;首先是&lt;code class=&quot;highlighter-rouge&quot;&gt;touchstart&lt;/code&gt;，这个事件被触发时，表示准备开始滑动了。这里不需要什么特别做的操作，只是对一些变量进行初始化，得到用户手指滑动的初始位置。这里我们设置了几个相对比较奇怪的变量。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var speedCalculator = new goog.structs.Queue();
speedCalculator.clear();
currentTouchMoveTime = this.getCurrentTime_();
lastTouchMoveTime = currentTouchMoveTime;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 &lt;code class=&quot;highlighter-rouge&quot;&gt;speedCalculator&lt;/code&gt; 中，我们规定只能存储五个队列元素。每一个元素中包含一个&lt;code class=&quot;highlighter-rouge&quot;&gt;distance&lt;/code&gt;和一个&lt;code class=&quot;highlighter-rouge&quot;&gt;time&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;distance&lt;/code&gt;是两次&lt;code class=&quot;highlighter-rouge&quot;&gt;touchmove&lt;/code&gt;被触发时所滑动的距离，&lt;code class=&quot;highlighter-rouge&quot;&gt;time&lt;/code&gt;就是这两次触发所间隔的时间。这些变量都是为之后模拟惯性行为所服务的。因为队列中的最后五个元素是手指触碰滑动的最后五个元素，是即将开始惯性运动前的五个元素，所以能够通过该变量计算出匀变速运动开始的初速度。&lt;/p&gt;

&lt;p&gt;接下来就是非常关键的函数之一 &lt;code class=&quot;highlighter-rouge&quot;&gt;touchmove&lt;/code&gt;。该方法被触发时，我们需要计算出手指滑动的距离，这个距离也就是column的边所滑动的距离（一段弧长）。需要注意的是，有些情况下手指滑动的距离并不是实际column需要滚动的距离。我们暂时先不考虑这种情况，之后会慢慢解释。&lt;/p&gt;

&lt;p&gt;现在得到了column需要滚动的距离之后，我们就可以计算出每一个item的新的&lt;code class=&quot;highlighter-rouge&quot;&gt;currentDegree&lt;/code&gt;，然后更新他们的style，并且显示在屏幕上。有一点需要注意，因为我们一共维护了&lt;code class=&quot;highlighter-rouge&quot;&gt;shownItems&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hiddenItems&lt;/code&gt;两个变量，所以我们每一次滑动之后，都需要更新这两个变量中的元素。如果一个元素的&lt;code class=&quot;highlighter-rouge&quot;&gt;currentDegree&lt;/code&gt;超出了一定的范围，就要把他放到&lt;code class=&quot;highlighter-rouge&quot;&gt;hiddenItems&lt;/code&gt;中，并且设置&lt;code class=&quot;highlighter-rouge&quot;&gt;currentDegree&lt;/code&gt;为0。如果有一个item需要显示在屏幕上，那就把他从&lt;code class=&quot;highlighter-rouge&quot;&gt;hiddenItems&lt;/code&gt;中取出，放进&lt;code class=&quot;highlighter-rouge&quot;&gt;shownItems&lt;/code&gt;中。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;滑动结束后的惯性行为&lt;/h4&gt;

&lt;p&gt;触碰结束后，系统会自动触发&lt;code class=&quot;highlighter-rouge&quot;&gt;touchend&lt;/code&gt;方法。在该方法中主要就是来模拟一下惯性行为（需要牵涉到一部分的物理知识）。为了方便，我们暂时只考虑匀减速运动，匀减速运动的公式为&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;S = Vt - at ^ 2 / 2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;计算出S后，就知道了column需要滚动的距离，之后的操作和&lt;code class=&quot;highlighter-rouge&quot;&gt;touchmove&lt;/code&gt;中的类似。为了得到S，我们需要知道V（初速度），a（加速度）和t（时间间隔）。V和t都能够通过&lt;code class=&quot;highlighter-rouge&quot;&gt;speedCalculator&lt;/code&gt;得到，a我们自己规定一下，就能够计算出一段时间间隔中column所滚动的距离了。&lt;/p&gt;

&lt;h4 id=&quot;item&quot;&gt;滑动速度小于某值时自动滚动到最近的item&lt;/h4&gt;

&lt;p&gt;当匀减速运动的速度小于某一个值时，column会自动滑动到最近的一个item。这也是非常合理的，总不能在两个item之间停下对吧。&lt;/p&gt;

&lt;p&gt;判断方法也非常简单，遍历所有的&lt;code class=&quot;highlighter-rouge&quot;&gt;shownItems&lt;/code&gt;，然后选择其中离column中间最短的一个，计算出它到column中间位置的弧长，这部分就是最后需要自动滚动的长度。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* @private
*/
Column.prototype.updateSelected_ = function() {
    var minDistance = goog.math.toRadians(Column.Const_.DEGREE_360) * Column.Const_.RADIUS;
    var minIndex = -1;
    goog.array.forEach(this.shownItems_, function(v, index) {
        var itemDegree = v[&#39;currentDegree&#39;];
        var distance = goog.math.toRadians(Column.Const_.DEGREE_90 - itemDegree) * Column.Const_.RADIUS;
        if (Math.abs(distance) &amp;lt; Math.abs(minDistance)) {
            minDistance = distance;
            minIndex = index;
        }
    }, this);
    this.selectedId_ = this.shownItems_[minIndex][&#39;id&#39;];
    this.dispatchColumnEvent_(Column.EventType.VALUE_CHANGE, null);
    this.autoScrollToSelectedItem_(minDistance);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;this.autoScrollToSelectedItem_(minDistance);&lt;/code&gt;就是我们真正自动滚动的函数。这个函数中，由于我们知道总距离，规定了自动滑动的时间，因此我们能够算出其加速度。再根据初速度，加速度和时间间隔，来计算出每一个时间片所滑动的距离即可。也没有什么难度。&lt;/p&gt;

&lt;h4 id=&quot;section-6&quot;&gt;规范化&lt;/h4&gt;

&lt;p&gt;什么是规范化呢？我们在实际计算滑动距离时间的时候，使用的都是double变量。这些变量在计算机中进行计算是有精度的损失的，因为计算机是没有分数的概念，所有的分数都会被转换成小数。例如，如果从数学理论上计算出的结果是150°，那么可能计算机给我们的结果就是149.99993°。这样的精度损失是会累加的，当我们进行数以千次的计算之后，可能最后的结果就变成了149°。1°的差距在屏幕上是很容易被发现的，尤其是这样的具有强烈对称性的滚轮组件。因此，每一次滑动结束后，我们都需要重新计算一下每一个item的位置，并且将他们移动到相应的位置上去。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* @private
*/
Column.prototype.itemPositionNormalization_ = function() {
    var selectedIndex = this.getSelectedIndexInShownItems_();
    goog.array.forEach(this.shownItems_, function(v, index) {
        var $item = v[&#39;item&#39;];
        var normalizedDegree = Column.Const_.DEGREE_90 - (selectedIndex - index) * Column.Const_.PER_DEGREE;
        v[&#39;currentDegree&#39;] = normalizedDegree;
        this.setShownItemStyle_($item, normalizedDegree);
    }, this);
    goog.array.forEach(this.hiddenItems_, function(v) {
        var $item = v[&#39;item&#39;];
        v[&#39;currentDegree&#39;] = 0;
        this.setShownItemStyle_($item, 0);
    }, this);
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-7&quot;&gt;真的随时都能滚动吗？&lt;/h4&gt;

&lt;p&gt;我们需要思考一点：如果相邻的item的距离是30°，那么column上最多同时显示的item数量是5个。如果本身item就少于5个怎么办？&lt;/p&gt;

&lt;p&gt;实际上现在手机的实现是这样的：如果item的数量过少，那么这个column是无法旋转到360°的。旋转到最上面或者最下面的时候，就不能在继续转下去了，同时松手就直接自动滚动到最近的那一个item。&lt;/p&gt;

&lt;p&gt;我们在代码中模拟的方法是，column实际滚动的距离是手指滚动的距离乘上一个系数。如果column可以360°滚动，那么这个系数就是1。反之，当用户滚动到最上面或者最下面的item的时候，系数会逐渐减小最终趋近于0.01。这样从效果上来看，就是column无法被滑动了。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/**
* @private
* @param {Number} exceed
* @return {Number}
*/
Column.prototype.itemExceedMoveCoefficient_ = function(exceed) {
    var coefficient = 1;
    var exceedLimit = Column.Const_.RADIUS * goog.math.toRadians(Column.Const_.PER_DEGREE);
    if (exceed &amp;gt;= exceedLimit) {
        coefficient = 0.01;
    } else {
        coefficient = 1 - ((1 - 0.01) / exceedLimit * exceed);
    }
    return coefficient;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;section-8&quot;&gt;公共接口&lt;/h4&gt;

&lt;p&gt;文章一开始提到过，data-picker是和其他component沟通的接口，在里面控制着data-picker-column的行为。column开放的接口大部分都是比较基础简单的，这里我就介绍一个可能会有一些实现难度的接口&lt;code class=&quot;highlighter-rouge&quot;&gt;setSelectedIndex&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;该接口在实现时，需要做几点：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;根据传入的index，重新计算&lt;code class=&quot;highlighter-rouge&quot;&gt;shownItems&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hiddenItems&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;根据&lt;code class=&quot;highlighter-rouge&quot;&gt;shownItems&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hiddenItems&lt;/code&gt;来重新绘制column&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;需要注意的是，该函数并不会有动画发生，而是直接重新绘制整个column。&lt;/p&gt;

&lt;h4 id=&quot;section-9&quot;&gt;性能&lt;/h4&gt;

&lt;p&gt;性能是data-picker一个非常重要的指标。针对性能已经做的优化有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;设置item的style： &lt;code class=&quot;highlighter-rouge&quot;&gt;display: absolute&lt;/code&gt;。这样在repaint和reflow的时候仅仅影响其column本身。&lt;/li&gt;
  &lt;li&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;hiddenItems&lt;/code&gt;中的元素，我们在滑动时不改变他们的style。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;但是我个人认为还有一些其他的地方可以改进：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;滑动时一次性修改&lt;code class=&quot;highlighter-rouge&quot;&gt;shownItems&lt;/code&gt;中所有元素的style。现在我们会遍历其中的元素，然后一个一个调用&lt;code class=&quot;highlighter-rouge&quot;&gt;setStyle&lt;/code&gt;方法，这个方法会导致repaint和reflow。实际上可以在遍历完之后，讲相应的计算得到的数据存储起来，然后进行一次性的绘制。&lt;/li&gt;
  &lt;li&gt;能否更好的建模。这个可能需要重构大部分的代码，但是我并不确定目前的实现是否是最合理的。把3D的模型转换成2D来处理需要大量的数学计算，能否直接建立成3D模型呢？&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;section-10&quot;&gt;后文&lt;/h2&gt;

&lt;p&gt;这个data-picker应该是我加入WAP之后做的最有挑战性的工作了。并没有谁让我去做这个东西，只是觉得现在mobile的组件还是比较匮乏的，如果能够实现出来，应该对其他产品也能有所帮助。当然，对我自己的提升也是巨大的。&lt;/p&gt;
</description>
        <pubDate>Sat, 05 May 2018 23:55:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2018/05/05/%E7%94%A8JS%E8%87%AA%E5%88%B6UIPickerView/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2018/05/05/%E7%94%A8JS%E8%87%AA%E5%88%B6UIPickerView/</guid>
        
        <category>Works Applications</category>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>使用GoogleClosureLibrary来制作MessageIndicator</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;概述&lt;/h2&gt;

&lt;p&gt;在做项目的时候遇到了一个需求，大概是这样的：&lt;/p&gt;

&lt;p&gt;在Sidemenu中，如果有太多用户未读的信息不能显示在页面中，就添加两个indicator，来提示用户。同时如果点击indicator，能够直接scroll到相应的未读信息。&lt;/p&gt;

&lt;p&gt;用文字说明很难解释清楚，直接放一张Slack的图吧，看了就能理解了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/slack.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当然最终的实现和Slack不完全一样。由于是机密信息所以就不放图了，下面的代码也是经过一些处理的。知道方法后自己实现一个还是非常简单的。&lt;/p&gt;

&lt;h2 id=&quot;html&quot;&gt;HTML&lt;/h2&gt;

&lt;p&gt;首先在HTML中添加相关的代码&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// 上方有未读消息的indicator
&amp;lt;div class=&quot;indicator indicator-top&quot; id=&quot;top-indicator&quot;&amp;gt;
    &amp;lt;span class=&quot;indicator-name&quot; th:text=&quot;More unread&quot; /&amp;gt;
    &amp;lt;span class=&quot;indicator-icon icon-arrow-up &quot; /&amp;gt;
&amp;lt;/div&amp;gt;
//下方有未读消息的indicator
&amp;lt;div class=&quot;indicator indicator-bottom&quot; id=&quot;bottom-indicator&quot;&amp;gt;
    &amp;lt;span class=&quot;indicator-name&quot; th:text=&quot;More unread&quot; /&amp;gt;
    &amp;lt;span class=&quot;indicator-icon icon-arrow-down&quot; /&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;代码很好理解，不做过多解释了。接下去我们需要修改相应的样式。&lt;/p&gt;

&lt;h2 id=&quot;less&quot;&gt;LESS&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;indicator {
    position:absolute;
    left: 4px;
    right: 4px;
    text-align: center;
    background-color: blue;
    cursor: pointer;
    transition: all 0.4s ease;
    color: white;
    padding: 4px;
    height: 26px;

    &amp;amp;-top {
        top: -26px;
        border-radius: 0 0 3px 3px;
    }

    &amp;amp;-bottom {
        bottom: -26px;
        border-radius: 3px 3px 0 0;
    }

    &amp;amp;-name {
        padding-right: 8px;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的地方是，我们需要判断是否有未读的信息没有显示在window内，再来决定要不要显示indicator。因此，在scroll的过程中，indicator的状态可能会发生改变（显示-&amp;gt;隐藏或者隐藏-&amp;gt;显示）。状态的改变需要平滑的过度，这里就使用CSS3的transition属性来实现，通过移动indicator的位置，来隐藏或者显示它。&lt;/p&gt;

&lt;h2 id=&quot;javascript&quot;&gt;Javascript&lt;/h2&gt;

&lt;p&gt;下面是核心部分。我们需要用JS在做几件事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;scroll的过程中判断是否要显示indicator&lt;/li&gt;
  &lt;li&gt;点击indicator跳转&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;首先是第一点。我们需要先找到第一个和最后一个未读的信息，代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var findFirstNewItem = function() {
    return goog.array.find(this.children_, function(child) {
      if (child.isNew()) {
          return child;
      }
    });
};

var findLastNewItem = function() {
    return goog.array.findRight(this.children_, function(child) {
      if (child.isNew()) {
          return child;
      }
    });
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;两个函数比较类似，一个是从数组头开始找，一个是从数组尾开始找。&lt;/p&gt;

&lt;p&gt;找到以后，我们判断他们的位置，并且设置indicator的状态：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var renderNewIndicator = function() {
    var container = getItemsContainer();
    var currentScrollTop = container.scrollTop;

    var firstItem = findFirstNewItem();
    if (goog.isDefAndNotNull(firstItem)) {
      var pos = goog.style.getPosition(firstItem);
      var size = goog.style.getSize(firstItem);
      if (pos.y + size.height &amp;lt;= currentScrollTop) {
        goog.style.setStyle(topIndicator, &#39;top&#39;, &#39;0px&#39;);
      } else {
        goog.style.setStyle(topIndicator, &#39;top&#39;, &#39;-26px&#39;);
      }
    } else {
      goog.style.setStyle(topIndicator, &#39;top&#39;, &#39;-26px&#39;);
    }

    var lastItem = findLastNewItem();
    if (goog.isDefAndNotNull(lastItem)) {
      var pos = goog.style.getPosition(lastItem);
      var containerSize = goog.style.getSize(container);
      if (pos.y &amp;gt; currentScrollTop + containerSize.height) {
        goog.style.setStyle(bottomIndicator, &#39;bottom&#39;, &#39;0px&#39;);
      } else {
        goog.style.setStyle(bottomIndicator, &#39;bottom&#39;, &#39;-26px&#39;);
      }
    } else {
      goog.style.setStyle(bottomIndicator, &#39;bottom&#39;, &#39;-26px&#39;);
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述代码大致就是在计算第一个和最后一个item是否出现在window之中，并且改变indicator的状态。&lt;/p&gt;

&lt;p&gt;有几点需要注意，&lt;code class=&quot;highlighter-rouge&quot;&gt;scrollTop&lt;/code&gt;是指某元素垂直方向scroll的距离，&lt;code class=&quot;highlighter-rouge&quot;&gt;getPosition&lt;/code&gt;得到的位置是相对于其父元素的。简单的计算就能得到正确的判断结果了。&lt;/p&gt;

&lt;p&gt;现在如何显示indicator已经实现，接下去我们要思考一下点击之后如何让页面scroll到相应的位置。&lt;/p&gt;

&lt;p&gt;首先我们绑定点击事件：
&lt;code class=&quot;highlighter-rouge&quot;&gt;
handler.listen(topIndicator, goog.events.EventType.CLICK, function() {
    var firstItem = findFirstNewItem;
    scrollToNode(firstItem, &#39;top&#39;);
});
handler.listen(bottomIndicator, goog.events.EventType.CLICK, function() {
    var lastItem = findLastNewItem;
    scrollToNode(lastItem, &#39;bottom&#39;);
});
&lt;/code&gt;
可以看到，我们在点击indicator之后，会直接scroll到相应方向最靠外侧的item。比如说如果我们点击了topIndicator，那么页面就会scroll到第一个未读消息的上方。反之如果点击bottomIndicator，就会scroll到最后一个。这样在点击某一方向的indicator之后，该方向上就不会再有屏幕外的未读消息了。&lt;/p&gt;

&lt;p&gt;具体scroll的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var scrollToNode = function(node, direction) {
    var container = getItemsContainer();
    var containerSize = goog.style.getSize(container);
    var nodePos = goog.style.getPosition(node);
    var nodeSize = goog.style.getSize(node);

    var oldPosY = container.scrollTop;
    var newPosY = oldPosY;
    if (direction === &#39;top&#39;) {
        newPosY = nodePos.y;
    } else if (direction === &#39;bottom&#39;) {
        newPosY = nodePos.y - containerSize.height + nodeSize.height;
    }
    var fxScroll = new goog.fx.dom.Scroll(container, [
        0, oldPosY
    ], [
        0, newPosY
    ], 500);

    fxScroll.play();
};
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;getPosition&lt;/code&gt;等方法已经解释过了，做一些数学的计算就可以。&lt;/p&gt;

&lt;p&gt;值得一提的是， &lt;a href=&quot;https://google.github.io/closure-library/api/goog.fx.dom.Scroll.html&quot;&gt;goog.fx.dom.Scroll&lt;/a&gt;是Google为我们封装好的，自动scroll到某位置的库。给定要scroll的容器，初始位置末位置，以及scroll的时间，就能够自动实现相应的功能。&lt;/p&gt;

&lt;p&gt;现在，MessageIndicator的功能已经大致实现了。之后考虑将其封装成一个js库，以便之后使用吧。&lt;/p&gt;
</description>
        <pubDate>Tue, 09 Jan 2018 00:55:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2018/01/09/%E4%BD%BF%E7%94%A8GoogleClosureLibrary%E6%9D%A5%E5%88%B6%E4%BD%9CMessageIndicator/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2018/01/09/%E4%BD%BF%E7%94%A8GoogleClosureLibrary%E6%9D%A5%E5%88%B6%E4%BD%9CMessageIndicator/</guid>
        
        <category>Works Applications</category>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Wap STM中随手写的一些web库</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;十一长假结束后，公司STM的第二个assignment也要进入尾声了。有了第一个assignment的经验，这次在具体开发的过程中遇到的问题就少了很多，我也把更多的重心放在了组件化上，尝试着去写一些公共的库文件来供他人使用。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;在这次的开发中，我一共提取出了三个公共库，分别与滑杆，分页器与图表有关。我将其相关的代码写在各自的文件中，使用一个类来封装，其他人使用时，只需要声明一个新的对象然后传入相应的参数即可，不需要关注其具体的实现。下面我将各自介绍这些库的实现细节与使用方法。&lt;/p&gt;

&lt;h3 id=&quot;slider&quot;&gt;Slider&lt;/h3&gt;
&lt;p&gt;这是一个滑杆库，&lt;a href=&quot;/js/slider.js&quot;&gt;点我下载slider.js&lt;/a&gt;。目前该slider使用的是双向设计，即有两个滑块，他们中间的范围为最终我们需要的值，设计图如下所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/slider.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
    name: string, // 该slider的名字
    target: jQuery Object, // 该slider所要放置的jQuery对象
    width: float, // slider的宽度
    height: float, // slider的高度
    barHeight: float, // slider中滑杆的高度，该值需要小于height
	extremum: { // slider的两个端值
        l: float,
        r: float
    },
    initial: { // slider的两个初始值
        l: float, 
        r: float
    },
    beginDrag: function, // 开始滑动滑块时触发的操作
    endDrag: function // 结束滑动滑块时触发的操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;整体实现的思路非常清晰，大致如下：
- 绘制滑杆，并且上色
- 根据slider的宽度、端值以及初始值绘制左滑块与右滑块
- 在左滑块与右滑块的中间添加一个&lt;code class=&quot;highlighter-rouge&quot;&gt;validZone&lt;/code&gt;，表示当前有效的范围，高度为&lt;code class=&quot;highlighter-rouge&quot;&gt;barHeight&lt;/code&gt;，并且进行上色（配色尽量与滑杆的颜色进行搭配）
- 绘制滑块Label，显示当前的数值
- 绑定事件&lt;/p&gt;

&lt;p&gt;在实现的过程中并没有太多困难的地方，唯一可能牵扯到一些数学知识的，应该就是计算滑块的位置。我们以左滑块为例，如果要计算它的初始位置，则公式如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(initial.l - extreme.l) / (extreme.r - extreme.l) * width
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;同理，如果我们已知左滑块的位置，要计算左滑块的值，可以通过如下的公式：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extreme.l + (leftPos / width) * (extreme.r - extreme.l)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在滑块滑动的过程中，我们会经常用到上述的两个公式，因此需要掌握其背后的原理（也是非常显而易见的）。&lt;/p&gt;

&lt;h3 id=&quot;pagination&quot;&gt;Pagination&lt;/h3&gt;

&lt;p&gt;在大学期间，我已经多次实现过分页器，但是都没有将其独立的作为一个模块拎出来。这一次用类来封装，也是希望能够测验一下自己对分页器的理解。&lt;/p&gt;

&lt;p&gt;很久之前就聊过，分页器分为前端分页和后端分页。在本项目中，由于我们没有构建一个独立的服务端，因此这里实现的分页器采用的是前端分页。后端分页如果要实现的话，对数据层的控制力度可能就要小一些，因为所有的数据都是从后台传进去的，分页器只是做了一个显示的作用。而前端分页不仅仅是显示，真正的分页过程也在这里进行，因此对分页器的封装更加友好。需要使用的朋友可以&lt;a href=&quot;/js/pagination2.js&quot;&gt;点我下载pagination.js&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;最终的设计图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/pagination.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
    name: string, // 分页器的名字
    target: jQuery.Object, // 分页器要放置的jQuery对象
    data: [], // 分页数据
    maxNumberOfButton: int, // 分页器最多同时显示的页码数量
    eachPageNumber: int, // 每个页面的条目数量
    clickEvent: function // 点击分页器页码时触发的操作
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化分页器，计算总共的页码数量，分页器同时显示的页码数量（小于或者等于&lt;code class=&quot;highlighter-rouge&quot;&gt;maxNumberOfButton&lt;/code&gt;）以及所要显示的页码。
- 绘制分页器。如果是第一页，则向左按钮失效（添加类&lt;code class=&quot;highlighter-rouge&quot;&gt;disabled&lt;/code&gt;），如果是最后一页，则向右按钮失效
- 点击事件，对传入的数据进行分页，并且重新绘制分页器。&lt;/p&gt;

&lt;p&gt;相对来说，比较复杂的在于第三步点击事件，这里我们需要重新计算所要显示的页码。定义当前页码为&lt;code class=&quot;highlighter-rouge&quot;&gt;curr&lt;/code&gt;，所要显示的页码数量的一半为&lt;code class=&quot;highlighter-rouge&quot;&gt;mid&lt;/code&gt;，总页码数为&lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果&lt;code class=&quot;highlighter-rouge&quot;&gt;maxNumberOfButton&lt;/code&gt;小于&lt;code class=&quot;highlighter-rouge&quot;&gt;total&lt;/code&gt;，那么我们可能会隐藏一部分页码不显示。例如，我们最大能够显示的页码量为5，但是这时候一共有7页，那么初始情况下需要显示的页码为1，2，3，4，5。第六页和第七页我们将其隐藏。如果我们单击页码4，那么需要显示的页码就变成了2，3，4，5，6。&lt;/p&gt;

&lt;p&gt;大致上来看，我们可以将需要显示的页码分为三类，则：
1. &lt;code class=&quot;highlighter-rouge&quot;&gt;curr &amp;gt;= 1 &amp;amp;&amp;amp; curr &amp;lt;= mid&lt;/code&gt;，则需要显示的页码为&lt;code class=&quot;highlighter-rouge&quot;&gt;1 ~ maxNumberOfButton&lt;/code&gt;。
2. &lt;code class=&quot;highlighter-rouge&quot;&gt;curr &amp;lt;= total &amp;amp;&amp;amp; curr &amp;gt;= total - mid + 1&lt;/code&gt;，则需要显示的页码为&lt;code class=&quot;highlighter-rouge&quot;&gt;total - maxNumberOfButton + 1 ~ total&lt;/code&gt;
3. 除此之外，需要显示的页码为，&lt;code class=&quot;highlighter-rouge&quot;&gt;curr - mid ~ curr + mid (- 1, 当maxNumberOfButton为偶数时)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;可以看到，在第三种情况中，当前的页码始终处于分页器的中间位置。&lt;/p&gt;

&lt;p&gt;整个分页器的难点就在于理清楚这三种情况。对于后端分页，我们就不再需要传入data，也不需要实际的分页操作，仅仅绘制分页器即可。&lt;/p&gt;

&lt;h3 id=&quot;chart&quot;&gt;Chart&lt;/h3&gt;

&lt;p&gt;图表是最为难以实现的一个模块库。在本项目中，我一共实现了三种类型的图表，无论从种类上还是性能上，都无法与市面上目前已经成熟的图表类库进行比较（例如acharts）。因此，对于我个人而言，这是一个完成项目所必须完成的工作，也是锻炼我js能力的一次考验。&lt;/p&gt;

&lt;p&gt;我将三种类型的图表写在了同一个文件中，&lt;a href=&quot;/js/chart.js&quot;&gt;点我下载chart.js&lt;/a&gt;，下面我将一个一个介绍。&lt;/p&gt;

&lt;h4 id=&quot;histogram-bar-chart&quot;&gt;Histogram （这里译名有点奇怪，我的锅，其实就是bar chart）&lt;/h4&gt;

&lt;p&gt;先来看一张效果图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/histogram.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
	name: string, // 柱状图的名字
	target: jQuery Object, // 柱状图所要放置的jQuery对象
	height: int, // 柱状图的高度
	width: int, // 柱状图的宽度
	legend: string, // 图例
	clickEvent: function, // 点击柱状图事件
	color: string, // 柱状图的颜色
	xAsix: Array, // 横坐标数据
	yAsix: Array // 横坐标数据所对应的值
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化坐标系，确定纵坐标的方向（正/负/双向）。
- 绘制图例
- 绘制纵坐标，根据&lt;code class=&quot;highlighter-rouge&quot;&gt;yAsix&lt;/code&gt;计算出纵坐标的最大值以及划分线的数量
- 绘制横坐标，动态绘制柱状条，并且在柱状体条上方添加数值标签
- 绑定鼠标覆盖事件以及点击事件&lt;/p&gt;

&lt;p&gt;其中，最为复杂的应该是绘制纵坐标以及动态绘制柱状条这两步。&lt;/p&gt;

&lt;p&gt;在绘制纵坐标中，我们需要先确定坐标轴的最大值。我们简单的通过yAsix中的最大值的最高位加一的方法来确定纵坐标端值。比如，如果&lt;code class=&quot;highlighter-rouge&quot;&gt;yAsix&lt;/code&gt;中最大值为75000，则坐标轴的最大值为80000；如果是98000，则最大值为100000。负数亦然，我们得到了&lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_yNegativePeak&lt;/code&gt;。接着我们需要计算出纵坐标轴正负两端划分线的数量。对于正负两端最大值数位多的那一端（假设为正方向端，即 &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak.str().length &amp;gt; _yNegativePeak.str().length&lt;/code&gt;)，其划分线的数量就是最高位（例外是，如果最高位为1，则数量为10）；数位少的那一端，通常情况下划分线的数量就是1。举个例子， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak&lt;/code&gt;为70000， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yNegativePeak&lt;/code&gt;为-3000，则正方向的划分线数量为7，具体是10000，20000，30000，40000，50000，60000，70000；负方向的划分线数量为1，具体是-3000。&lt;/p&gt;

&lt;p&gt;细心的读者可以发现，对于数位少的一端，我在划分线数量为1的前面加了一个定语“通常”，也就是说，有例外发生。这种情况出现在，两端最大值数位差为1，并且数位多的那一端的最高位为1（即 &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak.str().length - _yNegativePeak.str().length == 1 &amp;amp;&amp;amp; _yPositivePeak.str()[0] == &#39;1&#39;&lt;/code&gt;)。再这样的情况下，数位少的那一端划分线的数量也是其最高位。比如说， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yPositivePeak&lt;/code&gt;为100000， &lt;code class=&quot;highlighter-rouge&quot;&gt;_yNegativePeak&lt;/code&gt;为-40000，则正方向的划分线数量为10，具体是10000，20000，30000，40000，50000，60000，70000，80000，90000，100000；负方向的划分线数量为4，即-10000，-20000，-30000，-40000。&lt;/p&gt;

&lt;p&gt;这么设计看上去会有一些复杂，但是为了坐标轴更为美观，采用这样的方法我认为是很有必要的。他避免了两个问题：
1. 两端端值数位相差过大时，数位小的那一端划分线过于紧凑
2. 两端端值数位相差不大时，数位小的那一端划分线过于松散&lt;/p&gt;

&lt;p&gt;一句话来概括的话，就是正负两端划分线的间距要尽量保持一样，如果正方向划分线的间距时10000，那么负方向也要保持10000，否则就不划分（划分线数量为1）。这是一种保证柱状图坐标轴不会太丑的方法。&lt;/p&gt;

&lt;p&gt;第二个难点在于，如何动态绘制柱状条。这里我们用到了css3中的&lt;code class=&quot;highlighter-rouge&quot;&gt;-webkit-transition&lt;/code&gt;。我们对每一个柱状条进行如下的css设置：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;.bar{
    height: 0;
    &#39;-webkit-transition&#39;: &#39;height 1s&#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在将其加入到dom树之后，修改他的height为实际的高度，就能触发动画效果。&lt;/p&gt;

&lt;h4 id=&quot;pie-chart&quot;&gt;Pie chart&lt;/h4&gt;

&lt;p&gt;现在我们将介绍饼图，老样子还是先看图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/piechart.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
	name: string // 饼图的名字
	target: jQuery Object, // 饼图所放置的jQuery对象
	height: int, // 饼图的高度
	width: int, // 饼图的宽度
	legend: string, // 图例
	clickEvent: function, // 点击事件 
	data:[{ // 饼图的数据，包括文字描述，数据以及扇形的颜色
		label: string,
		value: int,
		color: string
	}]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化饼图，这里我们使用canvas来绘制
- 绘制饼图。如果是第一次绘制，则使用动画效果
- 绑定鼠标移动事件，在移动的过程中不停的重绘饼图，同时判断鼠标的位置是否在某一个扇形路径内，如果在，则可认为当前鼠标的位置覆盖了该扇形
- 绑定鼠标点击事件&lt;/p&gt;

&lt;p&gt;在饼图中，最为复杂的一点在于如何判断鼠标是覆盖了哪一块扇形。因为扇形是不规则的，我们不能像柱状图那样使用div来绘制，因此只能够使用canvas。而在canvas中，所有的图像都是一个整体，没有办法对每一个扇形进行单独的事件绑定，而需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;canvas.getContext(&#39;2d&#39;).isPointInPath(x, y)&lt;/code&gt;来判断一个坐标是否在canvas中的某一个路径内。在饼图中，我们按照顺时针的方向来绘制扇形，扇形路径绘制完毕后，我们马上进行&lt;code class=&quot;highlighter-rouge&quot;&gt;isPointInPath()&lt;/code&gt;的判定，就能够知道鼠标当前所覆盖的扇形是哪一个。这也就需要在mousemove事件中不停的重绘饼图，因为鼠标的坐标是不停的变化的。我原本以为这种方法的性能消耗会非常大，但事实上来看似乎并没有卡死的现象。如果有更好的方法也希望大家能够告知。&lt;/p&gt;

&lt;p&gt;除了判断鼠标位置所在的扇形之外，另一个有点难度的地方在于如何动态绘制饼图。所谓动态绘制，就是一点一点的来画图。原本可能90°的扇形一次性画完，动态绘制就将其分成90份，每次只绘制1°的扇形，重复绘制90次。理所应当的我们需要使用&lt;code class=&quot;highlighter-rouge&quot;&gt;setInterval&lt;/code&gt;函数，来重复绘制操作。绘制之前，我们先顺时针扫一遍所有的扇形，然后将扇形的终弧度保存在一个数组&lt;code class=&quot;highlighter-rouge&quot;&gt;angles&lt;/code&gt;中，以备后用，同时记录下当前正在绘制的度数 _timerCurrDraw。在具体的小角度的绘制过程中，我们先判定当前绘制的是哪一个扇形（通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;_timerCurrDraw&lt;/code&gt;与&lt;code class=&quot;highlighter-rouge&quot;&gt;angles&lt;/code&gt;中的元素进行比较），来决定绘制的颜色，然后进行path的绘制并且上色即可。如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;_timerCurrDraw&lt;/code&gt;大于了最后一个扇形的终弧度（为2π），则动态绘制结束。&lt;/p&gt;

&lt;h4 id=&quot;scatter-diagram&quot;&gt;Scatter diagram&lt;/h4&gt;
&lt;p&gt;翻译上来看，就是所谓的散点图，但其实与我们常见的散点图还有一些区别。除了点的分布以外，我所设计的scatter diagram还将空间分成了四个部分，每个部分都有其实际意义。对于点的分布，我也添加了一些新的含义，不同的颜色表示点不同的种类，而点的颜色深浅与半径的大小也区分了其在该类型中的等级。&lt;/p&gt;

&lt;p&gt;效果图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/scatter.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;所接受的参数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;config: {
	name: string // 散点图的名字
	target: jQuery Object, // 散点图所在的jQuery对象
	height: int, // 散点图的高度
	width: int, // 散点图的宽度
	group: [{ // 散点图中的各个类型，并且赋予其坐标
		x: float,
		y: float,
		label: string,
		color: string
	}]
	clickEvent: function, // 点击事件
	data:[{ // 各个点的坐标数值以及介绍
		x: float,
		y: float,
		info: string
	}],
	meaning: { // 坐标的含义
		x: string,
		y: string,
		xRate: bool,
		yRate: bool
	},
	zones: { // 散点图的四个区域的名称以及含义
		lt: string,
		ltexp: string,
		rt: string,
		rtexp: string,
		lb: string,
		lbexp: string,
		rb: string,
		rbexp: string
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;实现的思路如下：
- 初始化坐标轴，计算出&lt;code class=&quot;highlighter-rouge&quot;&gt;data&lt;/code&gt;中坐标进行平移的向量以及拉伸的系数，使之能够撑满&lt;code class=&quot;highlighter-rouge&quot;&gt;width&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;height&lt;/code&gt;
- 绘制坐标轴，解释坐标的含义并且画上划分线
- 绘制四个区域
- 对所有的散点进行分类
- 绘制坐标点，通过到类型坐标的距离来决定其颜色深浅和半径大小
- 绘制图例
- 绑定散点的覆盖和点击事件&lt;/p&gt;

&lt;p&gt;其中，最为复杂的，之一在于坐标轴的平移与拉伸。在本项目中，我们散点的横坐标与纵坐标都是百分数，也就是-1 ~ 1的区间，没有办法直接在图中转换为像素值，进行绘制。因此我们最先要做的，是将这些百分数的值转换成实际所要绘制的坐标值。在转换之前，我们需要计算一些初始数据：散点横纵坐标各自的最大值与最小值&lt;code class=&quot;highlighter-rouge&quot;&gt;maxX&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;maxY&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;minX&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;minY&lt;/code&gt;；散点的中心位置坐标&lt;code class=&quot;highlighter-rouge&quot;&gt;_graphCenterX&lt;/code&gt;， &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphCenterY&lt;/code&gt;；实际坐标系的中心位置 &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerX&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerY&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;通过这些值，我们需要算出如下信息：
1. 每一个散点在实际坐标系的位置&lt;code class=&quot;highlighter-rouge&quot;&gt;(data[index].x - _graphCenterX, data[index].y - _graphCenterY)&lt;/code&gt;
2. 拉伸系数。&lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleX = width / (maxX - minX)&lt;/code&gt;; &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleY = height / (maxY - minY)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;然后在计算散点实际绘制的坐标过程中，我们只需要对每一个散点在实际坐标系的位置先进行拉伸（将其乘上 &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleX&lt;/code&gt;和 &lt;code class=&quot;highlighter-rouge&quot;&gt;_graphScaleY&lt;/code&gt;）,然后按照一个方向向量进行平移（加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerX&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;_centerY&lt;/code&gt;)即可。&lt;/p&gt;

&lt;p&gt;之二在于散点的分类和绘制。对于点的分类，我采用的是类knn算法。每一种类型，我们都赋予其一个实际的坐标值&lt;code class=&quot;highlighter-rouge&quot;&gt;(group[index].x, group[index].y)&lt;/code&gt;，而对于每一个散点，我们计算出他到各个类型的坐标的距离，取其最短，将该散点归类到该类型中。在同一种类型中，我们计算出其中所有的散点到类型坐标的距离，根据距离的长短来决定其颜色深浅以及半径大小，完成最终的绘制。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用说明&lt;/h3&gt;

&lt;p&gt;至此，在本项目中封装好的类都已经介绍完毕了。使用方法大同小异：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var a = new B({
    ... // 根据每一个类传入所需要的参数值
})
a.render()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;执行上述代码后就能正常使用该类了。&lt;/p&gt;

&lt;h2 id=&quot;section-3&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;NONE&lt;/p&gt;

</description>
        <pubDate>Mon, 09 Oct 2017 16:17:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/10/09/Wap-STM%E4%B8%AD%E9%9A%8F%E6%89%8B%E5%86%99%E7%9A%84%E4%B8%80%E4%BA%9Bweb%E5%BA%93/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/10/09/Wap-STM%E4%B8%AD%E9%9A%8F%E6%89%8B%E5%86%99%E7%9A%84%E4%B8%80%E4%BA%9Bweb%E5%BA%93/</guid>
        
        <category>Works Applications</category>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Wap STM Web开发心得</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;这一周其实过的很不好，算是自己近两年来，心情最糟糕的一周。&lt;/p&gt;

&lt;p&gt;我一直告诉自己，活到现在，其实是没有什么事情需要后悔的。如果有第二次机会的话，我想收回上周三晚上说的所有的话，对不起。&lt;/p&gt;

&lt;p&gt;所谓冲昏了头脑，大抵如此。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;p&gt;这一个月里，一直都在做一个Personal Information System。做的过程中因为是不允许上网的，所以还遇到了不少的问题要去解决。本文就具体介绍一下这些问题，以后遇到的时候也有一个解决方案。&lt;/p&gt;

&lt;p&gt;当然，由于公司要求保密，因此相关的细节代码不会公开。&lt;/p&gt;

&lt;h3 id=&quot;webkitrequestfilesystem&quot;&gt;使用webkitRequestFileSystem来导出文件&lt;/h3&gt;

&lt;p&gt;这部分是HTML5的File API的部分。之前在我印象中，只有IE有相应开放的接口来操作本地文件的。HTML5出来之后，主流的浏览器都已经支持这样的操作了，像是webkit内核的chrome浏览器等。&lt;/p&gt;

&lt;p&gt;由于该功能的代码与项目有密切联系，这里就不多介绍了。如果相关开发人员需要在本地导出文件，可以考虑使用该API来实现。&lt;/p&gt;

&lt;h3 id=&quot;webkit-user-select&quot;&gt;-webkit-user-select&lt;/h3&gt;

&lt;p&gt;我们知道，如果我们把鼠标放到浏览器的文字上面，那么鼠标的标志会变成编辑状态。如果我们按下并且拖动，那么这部分的文字将会被选中进行高亮显示。如果我们再按下鼠标，会发现这部分文字是可以被拖动的（在html中表现为draggable属性为true）。&lt;/p&gt;

&lt;p&gt;在本项目中，这种行为是非常危险的。因为我们可以拖动整个table的column，来改变他们的顺序，因此每一个元素的draggable属性必须要个的由我们的代码来控制，一些浏览器默认的行为需要被禁止，包括我们上文提到的选中文字拖动操作。&lt;/p&gt;

&lt;p&gt;具体的禁止方式，就是在css中，把-webkit-user-select属性进行修改：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;body{
	-webkit-user-select: none;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该属性设置成none之后就音质用户在页面上进行文字的选中。当然-webkit前缀规定了适用于chrome等浏览器，其他内核浏览器也有相应的修改方法，这里就不再阐述了。&lt;/p&gt;

&lt;h3 id=&quot;table&quot;&gt;修改table的宽度。&lt;/h3&gt;

&lt;p&gt;在本项目中，我们提供给用户一个功能，可以让他们随意来修改column的宽度。如果有很多column的话，用户可以将他们的宽度设置的小一点，这样就能看到更多了，提高用户体验。&lt;/p&gt;

&lt;p&gt;但是在具体的实现过程中，由于table本身有自适应的功能，以及jQuery本身的函数实现不同，会有很多的问题所在，这里就简单阐述一下设置的几点规则。&lt;/p&gt;

&lt;p&gt;一般而言，table的自适应是由于所有column宽度加起来不等于table的宽度而导致的。&lt;/p&gt;

&lt;p&gt;在自适应的过程中，table会优先改变从来没有设置过宽度的column，而table整体的宽度是保持不变的。&lt;/p&gt;

&lt;p&gt;如果所有的column的宽度都被制定过，那么我们在修改一个column的宽度时，其他所有column的宽度都会被改变。这种情况是非常糟糕的，一般都是不符合要求的。&lt;/p&gt;

&lt;p&gt;因此，如果我们要定制每一个column的宽度，我们有如下两种相对理想的解决方案。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设置每一个column的宽度，并且计算总宽，赋值给table。确保table的宽度等于所有column的总宽。&lt;/li&gt;
  &lt;li&gt;保留一个column永远不设置宽度，做自适应项。（一般就是加一个空列）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;知道了规则，实现起来就方便很多了。然而，如果我们使用jQuery的$.fn.width()函数，我们会发现始终达不到我们的目标。原因是，$.fn.width()函数在box-sizing属性为border-box的元素中，不会计算其padding。而如果我们用bootstrap等常用的UI库做table时，通常都会有一个padding。因此在计算总宽时，除了对每一个column使用$.fn.width()函数外，也要加上padding值。&lt;/p&gt;

&lt;p&gt;还有一个解决的方案是不使用$.fn.width()函数，而是用$.fn.css(‘width’)，这样的话我们得到的宽度是算上padding的。但是注意该函数返回的结果是一个string，并且包含px等后缀，需要自行处理。&lt;/p&gt;

&lt;h3 id=&quot;ufeff&quot;&gt;神秘前缀\ufeff&lt;/h3&gt;

&lt;p&gt;这其实是uft-8的一个bom头。所谓bom头，就是用来标识该文件属于utf-8编码。由于我们项目中导出txt，csv文件这个功能里可能会包含有中文的字符，因此我们需要使用uft-8编码。&lt;/p&gt;

&lt;p&gt;这个bom头是微软自己规定的，他建议所有的 Unicode 文件应该以 ZERO WIDTH NOBREAK SPACE（U+FEFF）字符开头。这作为一个“特征符”来识别文件中使用的编码和字节顺序。但是目前，该bom头的兼容性并不好，只在windows操作系统相应的文件读取软件中使用，例如记事本等。如果我们用记事本打开一个文件，用uft-8格式保存之后，就会发现自动带上了这样一个bom头。&lt;/p&gt;

&lt;p&gt;本项目中，我们默认文件下载之后是需要用记事本来打开的，并且需要支持非英文字符，因此我们加上一个前缀\ufeff来告诉它，这是uft-8编码的字符串，这样才能得到正确的显示结果。&lt;/p&gt;

&lt;h3 id=&quot;roll-back&quot;&gt;roll back系统&lt;/h3&gt;

&lt;p&gt;为了防止用户误操作或者一些恶意操作，我们系统增加了一个回滚功能。具体的功能和git reset比较类似。&lt;/p&gt;

&lt;p&gt;我们记录用户所有的操作，包括对employee信息的修改以及对list的自定义。一条记录包括修改的时间，修改的用户，在什么上进行了修改，修改了什么，修改之前的数据和修改之后的数据等。用户随时都可以查看这些记录，如果点击了其中的一条记录，将会被roll back的所有记录都会被高亮显示，如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/2.JPG&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里需要注意，如果是set default操作，那么在该记录之前的所有set default操作都会被回滚。如果是其他操作，那么该记录之前的作用与同一目标的所有操作会被回滚。这两条是我根据用户可能希望的结果自己制定的规则，之后可能会有所更改。&lt;/p&gt;

&lt;p&gt;实际的回滚操作还是比较简单的，我们已经有了所有要回滚的记录，根据第一条的记录的after以及最后一条记录的before来决定回滚所要执行的操作，然后将目标的值（assemble的column，employee的信息等）恢复为最后一条记录的before即可。&lt;/p&gt;

&lt;h3 id=&quot;textpixel&quot;&gt;测得一个text所占用的pixel&lt;/h3&gt;

&lt;p&gt;这部分其实是一个相对比较trick的实现。既然我们没有办法通过具体的某一个函数代码来计算出像素值，那么我们就将这部分文字放到dom中，看看实际占用多少就可以了。&lt;/p&gt;

&lt;p&gt;因此，我们新建一个&amp;lt;div&amp;gt;元素，设置如下的css:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#columnLengthCount{
	visibility: hidden;
	float: left;
	font-weight: bold;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;float属性可以让&amp;lt;div&amp;gt;的宽度根据text的长度来自适应。最后我们得到的该&amp;lt;div&amp;gt;的宽度就是一个text所占用的pixel了。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;双击和单击事件&lt;/h3&gt;

&lt;p&gt;在js的实践中，同时存在单击和双击事件。如果我们就正常的添加这两个事件的话，想要执行一次双击事件会额外执行两次单击事件。&lt;/p&gt;

&lt;p&gt;因此，在通常情况下，我们需要屏蔽掉这两次单击事件，仅仅执行双击。一般的解决方案是添加一个计时器，如果双击的时间间隔超过一个阈值，则看做是单击。如果时间间隔小于这个值（一般是0.3秒左右），则看做是双击。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$.fn.click(function(){
	clearTimeout(timer);
	timer = setTimeout(function(){
		...
	}, 300);
})

$.fn.dblclick(function(){
	clearTimeout(timer);
	...
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;点击空白处弹窗消失&lt;/h3&gt;

&lt;p&gt;在本项目中，使用到了一部分的弹窗：搜索框和回滚系统数据查看框。这部分弹窗使用的是bootstrap中的popover组件。该组件默认情况下是点击按钮出现，再点击按钮则消失。但是有时候，我们需要实现的效果是，点击按钮出现，然后点击任意其他空白位置消失。这样做可以提高用户的使用效率而不需要再去点击按钮。&lt;/p&gt;

&lt;p&gt;实现的思路很简单，在document绑定一个click时间，如果点击的位置不在弹窗内，则执行弹窗消失的操作：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$(document).click(function(e){
	var _con = $(&#39;.popover&#39;);
	if (!_con.is(e.target) &amp;amp;&amp;amp; _con.has(e.target).length === 0){
		... //popover disappears
	}
})
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里_con就是我们显示的popover，如果点击事件的目标不是popover或者其子元素，则将其消失。&lt;/p&gt;

&lt;p&gt;That’s all.&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;明天七夕节，欢迎来约。&lt;/p&gt;

&lt;p&gt;干什么都可以，我奉陪到底，我买单到底。&lt;/p&gt;

</description>
        <pubDate>Sun, 27 Aug 2017 20:51:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/08/27/Wap-STM-Web%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/08/27/Wap-STM-Web%E5%BC%80%E5%8F%91%E5%BF%83%E5%BE%97/</guid>
        
        <category>Works Applications</category>
        
        <category>Web</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Wap入职第一周元气满满</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;毕业之后一直就无所事事，每天也就打打游戏偶尔出去聚会吃饭，晚上跑个步。所以整个七月过去的都非常的快，转眼间就要入职了。&lt;/p&gt;

&lt;p&gt;可能是因为日子轻松惯了，我也没有感觉这一刻有多么的“神圣”，就像一首歌里说的那样：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;其实爱对了人，情人节每天都过。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然而这实实在在的确实是我人生中新的篇章，因为16年的学生时代就此画上句号。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;入职仪式&lt;/h3&gt;

&lt;p&gt;入职仪式在环球港的凯悦酒店进行。首先就是大BOSS们的讲话和欢迎仪式啦。有意思的是，我们有个HR大BOSS竟然连英文都不会说！真是难以想象霓虹国外语教学水平。他在演讲的时候，用的是日语，然后hr姐姐同声翻译（我想说的是这个HR姐姐长得超级超级超级可爱qwq）。我学过一点日语啦所以听懂还是问题不大的。&lt;/p&gt;

&lt;p&gt;然后是介绍一下各种职场的危险情况，包括性骚扰和职权欺凌。性骚扰讲了很久啊，之前看日剧就对日本的职场性骚扰有过耳闻，是不是这样的情况在日本真的很多？所以需要特别强调一下？&lt;/p&gt;

&lt;p&gt;然后就是大家进行一张合照啦！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/WAP/1.JPG&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之后就去我们的办公桌了。不得不承认，环球港B座真的是非常的气派，特别是那个电梯，可能是我孤陋寡闻了，有低中高三层也就算了，还不能自由选择楼层。你能前往的楼层由你的工卡决定。。。安全性满分。&lt;/p&gt;

&lt;p&gt;找到了自己的工位，拆电脑，装电脑，下软件，然后就开始干活啦！Fighting！！！&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;关于一天的生活&lt;/h3&gt;

&lt;p&gt;工作的生活其实并没有我想象中的那么累，只不过有些地方需要自己去慢慢适应。不如扯扯我的一天是怎么度过的哈哈哈哈哈哈。&lt;/p&gt;

&lt;h4 id=&quot;section-4&quot;&gt;早上&lt;/h4&gt;

&lt;p&gt;7:20 起床，洗漱，穿好&lt;em&gt;西装&lt;/em&gt;。如果想要稍微帅气一点，就带个小领带。说道领带，我买了一根细的，带上去就发现自己根本不像一个上班的人233学生气十足。&lt;/p&gt;

&lt;p&gt;8:00 坐上陆安专线B线。由于我家的地(niao)理(bu)优(la)势(shi)，我上班只需要坐着一辆公交就可以，而且它会走高速公路，所以一般而言，9:15就能到公司。&lt;/p&gt;

&lt;p&gt;9:10 下车，去全家买早饭，心情好就买一杯咖啡喝喝。&lt;/p&gt;

&lt;p&gt;9:15 到公司，开始一天的工作。一般会先检查邮箱，git上进行代码的更新。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;下午&lt;/h4&gt;

&lt;p&gt;13:00 吃饭。不得不吐槽一下，在环球港吃饭！！！实在是！！！太贵了！！！每天只能去大食代吃，一般而言，30元RMB左右能够填饱肚子。虽然我知道日本更贵，但是让我一个刚从学校食堂10块吃饱的环境出来有点不太习惯呀。&lt;/p&gt;

&lt;p&gt;14:00 开始了下午的coding。我属于那种不能专注很久的，所以我有时候回去吧台（公司的）找找杂志看，或者喝一杯牛奶，放松一下继续工作。&lt;/p&gt;

&lt;p&gt;18:30 这是STM阶段理论上的下班时间，然而，然而！到了这个点，几乎是没有人走的，我的内心是崩溃的，大家要不要这么认真？？？？&lt;/p&gt;

&lt;p&gt;19:00 差不多陆陆续续的走了，包括我。&lt;/p&gt;

&lt;p&gt;19:40 坐上北安线，可能没有座位。听听歌，看看窗外两眼放空。这是我一天中最享受的时候。&lt;/p&gt;

&lt;p&gt;20:30 到家，吃饭，洗澡，睡觉。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;关于工作&lt;/h3&gt;

&lt;p&gt;由于我们是刚入职的员工，所以需要经历为期两个月到三个月的STM(starter mission)。&lt;/p&gt;

&lt;p&gt;STM由三个部分组成。&lt;/p&gt;

&lt;p&gt;第一个部分是基础知识，就是简单培训一下需要用到的知识。&lt;/p&gt;

&lt;p&gt;第二部分和第三部分都是相关的项目。项目包括Catalog和Implementation。具体的东西因为是公司机密所以我就不谈了哈，总之，我们的任务不仅仅是写代码，更多的是对产品的思考和定位，也就是，你是自己的产品经理和工程师。&lt;/p&gt;

&lt;p&gt;项目的难度其实并不大，主要是能不能有创造力的挖掘出产品的价值。目前来看我的实现还算比较顺利，也可能是因为我之前有相关开发网页的经历。我现在就希望能够快点结束STM，因为我不想穿西装上班啊qwq。&lt;/p&gt;

&lt;p&gt;在STM阶段，我们的网络访问也是有限制的，只能获取非常少的一部分英文资料，而且也没有wifi，手机上网全靠流量。值得一提的是，在网页白名单中，有requirejs和commonjs。这两个都是和js模块化有关的工具，后者我用的还是比较多的。但是，但是！commonjs仅仅定义了模块化的规则，并没有提供相关的编译方案（也就是没有webpack和browserify这样的工具）。所以实际上，如果要做模块化的话，还是要学习一下requirejs的使用。下一篇博客就来介绍一下这方面的东西吧！&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;上班怎么说，还是比较轻松愉快的吧。当然我明白在结束STM之后，真正的任务会接踵而至。&lt;/p&gt;

&lt;p&gt;目前来看，我现在最期盼的日子，一个是8月12日，TI7决赛，另一个是8月25日，发薪水。&lt;/p&gt;

&lt;p&gt;就是酱，喵！&lt;/p&gt;

</description>
        <pubDate>Sun, 06 Aug 2017 22:22:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/08/06/Wap%E5%85%A5%E8%81%8C%E7%AC%AC%E4%B8%80%E5%91%A8%E5%85%83%E6%B0%94%E6%BB%A1%E6%BB%A1/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/08/06/Wap%E5%85%A5%E8%81%8C%E7%AC%AC%E4%B8%80%E5%91%A8%E5%85%83%E6%B0%94%E6%BB%A1%E6%BB%A1/</guid>
        
        <category>Works Applications</category>
        
        <category>生活</category>
        
        
      </item>
    
      <item>
        <title>Acemap学术地图功能和性能的完善</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;说一点题外话，我最终还是决定去东京。不是为了生活的有多好，只是想出去走走多看看世界。如果东京也能够容下我，那我应该也会定居在那里吧。&lt;/p&gt;

&lt;p&gt;其实是一个很艰难的决定，因为要顾忌到的东西有太多了。包括朋友，家人，还有东京那里的生活节奏，个人习惯等。我知道自己如果要考虑的话，还能纠结个几个月。但是纠结的日子是很痛苦的，想快点摆脱这种困扰，就狠下心来让自己做这个决定。嗯，他也是一个很草率的决定。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;功能&lt;/h3&gt;

&lt;p&gt;上次在寒假那会儿已经把话题地图给完成了，而且将map和searchBar的公用部分代码都已经提取出来了。因此，剩下来功能上的部分就相对来说比较简单一些，只需要套用模板就行。&lt;/p&gt;

&lt;p&gt;首先是机构地图。机构地图，顾名思义，就是以一个机构为中心，该机构中的作者为节点显示的一张图。&lt;/p&gt;

&lt;p&gt;原先，我们地图中的所有线条都是直线的，这样并不美观。因此我们在这里将点与点之间的边用一根贝塞尔曲线来表示，具体绘制的函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function pathd(source,target,bezierCurveness){
	var x1 = Number(source.x);
	var y1 = Number(source.y);
	var x2 = Number(target.x);
	var y2 = Number(target.y);
	var length = Math.sqrt(Math.pow(x1-x2,2)+Math.pow(y1-y2,2));
	var factor = bezierCurveness*length;
	var v1_X = ((x2-x1+y2-y1)*factor+x1*length)/length;
	var v1_Y = ((y2-y1+x1-x2)*factor+y1*length)/length;
	var v2_X = ((x1-x2+y2-y1)*factor+x2*length)/length;
	var v2_Y = ((y1-y2+x1-x2)*factor+y2*length)/length;
	var result = &quot;M &quot;+String(x1.toFixed(6))+&quot;,&quot;+String(y1.toFixed(6))+&quot; C &quot;+String(v1_X.toFixed(6))+&quot;,&quot;+String(v1_Y.toFixed(6))+&quot; &quot;+String(v2_X.toFixed(6))+&quot;,&quot;+String(v2_Y.toFixed(6))+&quot; &quot;+String(x2.toFixed(6))+&quot;,&quot;+String(y2.toFixed(6));
	return result;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;该函数能够根据两个节点的坐标以及贝塞尔曲线的弧度来返回svg的路径。事实证明在美观程度上有了很大的提高，现在的UI如下图所示。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;因为急着上线，因此没有截取之前UI的图片，大家脑补一下即可。&lt;/p&gt;

&lt;p&gt;然后另外一张新地图是合作者地图，也就是以一个作者为中心，其他合作者为节点的地图。&lt;/p&gt;

&lt;p&gt;这个地图其实要改的东西还是非常之多的。除了将svg从前端生成，把左边的侧栏实现之外，还需要将原先作者页面的所有信息都搬到地图中。这对信息的筛选和整合是一个非常大的挑战。&lt;/p&gt;

&lt;p&gt;但是，这部分挑战仅仅是产品上的问题，只要我们知道要哪些东西，舍弃哪些东西，在技术上实现是没有难度的。唯一一个比较困难的问题是作者论文这一块。因为一个作者的论文数量有很多（最多的达8000+），因此我们需要添加一个分页的功能。那么究竟是前端分页还是后台分页呢？事实上，在目前绝大多数的上线产品中，分页都是使用后台分页的。如果我们数据量很大，大到需要分页的话，那么一次从后台传输这些数据的耗时是非常高的。我们将数据从数据库中取出来的时候就规定好一个start和一个offset，这样我们进行一次数据请求，返回的内容仅仅为一页所需要的内容。这么做虽然时间上有了节约，但是我们每一次分页都需要重新向后台请求数据。大部分情况下，后台分页比前段分页是有优势的。&lt;/p&gt;

&lt;p&gt;除此之外，论文部分还添加了一个根据年份筛选的功能。该功能直接将参数传入后台，在SQL语句中添加WHERE即可，没有难度。&lt;/p&gt;

&lt;p&gt;啊对了，这个分页器也是我自己写的，已经包装在一个文件中了。因为原先是想自己使用，因此也没有在接口和库文件规范上有下功夫，不过在这里我依然把代码公开一下，感兴趣的朋友可以自己用用看。&lt;a href=&quot;/js/pagination.js&quot;&gt;pagination.js&lt;/a&gt;，依赖于bootstrap和jquery。&lt;/p&gt;

&lt;p&gt;使用方法很简单，在html中插入如下语句：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;ul class=&quot;pagination pagination-sm&quot;&amp;gt;&amp;lt;/ul&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，在js中初始化该pagination，初始化函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;function initPagination(number, func)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;参数number是总共的页数，func是单击页码时执行的数据操作（一般也就是请求后台）。&lt;/p&gt;

&lt;p&gt;下面放上一张合作者地图新的UI图吧！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;之前已经完成的话题地图也做了一点改进，将年份选择做成了滑杆的形式，两个滑块之间的就是选择的年份区间。滑杆就没有自己写了，用的是nst-slider这个第三方库，还是比较方便的。&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;性能&lt;/h3&gt;

&lt;p&gt;前端性能上的提高就不提了，主要就是整理代码，减少重复的事件绑定和后台请求。这次主要是后台上的性能提高。&lt;/p&gt;

&lt;p&gt;首先是SQL上的query cache。之前我们把query cache一直都是打开的，然后有时候请求返回的速度就很慢。查log之后发现SQL一直在输出waiting for query cache lock。查阅了一下网上的资料，发现该cache会缓存之前使用过的SQL查询语句以及查询结果。这对于一些我们经常查询一样的内容并且表内容不频繁变化的情况会比较有用。但是在acemap中，我们每一次查询的内容几乎都是不同的，像paperid，authorid都是想变就变的。因此我们每一次查询的时候，就会刷新这个cache，刷新这个cache又会上锁。因此在并发数达到一定的情况下，就会有明显的卡顿现象了。&lt;/p&gt;

&lt;p&gt;然后是redis缓存。我们在话题地图的前50名作者功能中，使用了redis作为数据缓存。因为这个表的大小很大，如果每一次都从SQL中取出的话，会很占用时间。redis将数据缓存在内存之中，而且并不是使用表结构，而是我们代码中更为常见的字典结构，一个key对应一个value，因此使用上也非常的方便。在后台我们判断一下在redis中是否有数据缓存即可：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;if ($redis -&amp;gt; hExists($topicID, &#39;famousAuthor&#39;)){
	$authors = json_decode($redis -&amp;gt; hGet($topicID, &#39;famousAuthor&#39;), TRUE);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大概就是这样。&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;目标&lt;/h3&gt;

&lt;p&gt;目前我们所有的地图上的功能都已经实现了，下一阶段会着重在搜索这一块。搜索组已经在后台开始使用了solr引擎，只不过目前还没有移植到前端。之后在了解了相应的使用方法之后，我会及时的在前端跟进的。&lt;/p&gt;

&lt;h2 id=&quot;section-5&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;看我这么认真的做毕设写博客的份上，求天赐我一个女朋友。&lt;/p&gt;

</description>
        <pubDate>Sat, 15 Apr 2017 12:45:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/04/15/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E5%96%84/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/04/15/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%8A%9F%E8%83%BD%E4%B8%8E%E6%80%A7%E8%83%BD%E7%9A%84%E5%AE%8C%E5%96%84/</guid>
        
        <category>Acemap</category>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>Acemap学术地图前端代码的重构</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;今天是个美好的日子，只可惜不属于我而已。虽然没有出去约女孩子，但一个人在宿舍学完一课日语，健身房里跑跑步，打打游戏晚上再写下这篇博文，也是非常惬意的。&lt;/p&gt;

&lt;p&gt;这是一篇关于毕业设计的博文。之前在选择毕设的时候也是一波三折，因为老师名额不够，所以导致我需要去补录志愿。所幸最后老师帮我争取到了一个名额，能够让我成功获得毕业的机会。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;section-2&quot;&gt;毕设主要内容&lt;/h3&gt;

&lt;p&gt;我的毕设是纯工程的，没有什么理论。也就是说，不需要看大量论文，大部分的工作还是写代码。要做的是一个学术地图，名字叫做&lt;a href=&quot;http://acemap.sjtu.edu.cn&quot;&gt;Acemap&lt;/a&gt;。在我加入项目组之前，已经完成了一部分工作了，但是代码质量参差不齐。最后的项目目标是，能够将所有的地图都统一起来，有统一的格式。具体的UI可以参考谷歌地图。我负责的部分是前端，总体来说，我要做的内容就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;设计合适的前端代码架构&lt;/li&gt;
  &lt;li&gt;重构前端代码，理清结构&lt;/li&gt;
  &lt;li&gt;设计UI&lt;/li&gt;
  &lt;li&gt;功能实现&lt;/li&gt;
  &lt;li&gt;完成文档和注释内容&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;代码架构&lt;/h3&gt;

&lt;p&gt;我们后台使用的是CodeIgniter框架。说实话，这个框架已经老的掉牙了，可能是之前几年的学长挑选的，现在要更换也已经几乎是不可能的了，因为代码数量已经非常庞大了。学习了一下CodeIgniter，个人感觉还是挺麻烦的。而且，在controller如何控制view的那段示例代码中，有类似如下的片段：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$this -&amp;gt; load -&amp;gt; view(&#39;header&#39;);
$this -&amp;gt; load -&amp;gt; view(&#39;content&#39;);
$this -&amp;gt; load -&amp;gt; view(&#39;footer&#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终我们显示的代码，是这三个文件中代码的顺序拼接。这样做其实我自己很不喜欢，原因有如下几点：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;每一个文件的代码都没有完整的html格式&lt;/li&gt;
  &lt;li&gt;最终显示页面的html源代码不够直观，需要看多个文件&lt;/li&gt;
  &lt;li&gt;模块化不够明显。虽然header也可以作为某一个单独的模块列出来，但是其必定会带有一些html标签，在使用的时候不够方便。而且他只支持顺序的模块，没有办法实现一个模块中嵌套另一个模块。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;原本我最理想的而前端架构是用ReactJS或者VueJS，因为最终页面的风格是要统一的，公共的部分包括&lt;em&gt;搜索栏&lt;/em&gt;， &lt;em&gt;svg地图&lt;/em&gt;，因此只要将这两者作为模块单独放在文件中，由外界向他们传数据就可以很好的进行复用。这么做的话，最理想的是在基础页面加载完毕后，再通过RESTFUL API向后台请求获得具体的数据。但是，目前我们后台是将页面需要的数据直接传递给页面的，这样做的话，我们的页面必须以php结尾，才能够使用那些传递过来的数据，但即使这么做了，JS代码里是不能够嵌入PHP代码的，因此我们没有办法让ReactJS/VueJS模块得到后台controller直接传过来的数据，这样的代码架构就不能实现。如果要做的话，后台的代码就要重构，前端的代码也要重构，工作量之大并不是目前能顾得上的。&lt;/p&gt;

&lt;p&gt;因此，前端这一块，目前并没有使用任何的框架。只是用了jQuery以及相关的一些库。因为jQuery是没有模块化的，因此我们也没有办法使用npm来引入相关的jQuery第三方插件。项目整体还是比较原始的，目前来看的话，也只能这样子了。&lt;/p&gt;

&lt;p&gt;最终我对这个项目的前端代码框架的构思是，将&lt;em&gt;搜索栏&lt;/em&gt;，&lt;em&gt;svg地图&lt;/em&gt;这两个可以复用的部分的js代码单独拿出来建一个文件，然后一个页面只使用一个.php文件，页面中需要用到的特定的js代码以内联的方式写在.php文件中。这样可以在保证代码清晰的前提下，能够最大程度的复用一些组件。&lt;/p&gt;

&lt;h3 id=&quot;svg&quot;&gt;SVG地图生成&lt;/h3&gt;

&lt;p&gt;在我加入项目组之前，SVG地图是已经在后台生成完毕，作为一个单独的文件，在controller中进行拼接的。这样做有好处也有坏处，好处是加载的速度比较快，坏处就是可拓展性不强，如果有新的地图，我们就需要在后台重新生成一边，相对而言也比较占用空间。&lt;/p&gt;

&lt;p&gt;目前我们已经抛弃了这样的方式，取而代之的是，用js代码来生成相应的svg地图。我们在后台存储了相应的地图所需要的元素，并用如下的代码读取出来：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$sql = &quot;SELECT PaperID, Radius, X, Y, View1, View2, Year, JournalID, ConferenceID, LabelSize, LabelX, LabelY, Label FROM papermap_4_node WHERE FieldID = ?&quot;;
$nodes = $this-&amp;gt;db_svg-&amp;gt;query($sql, array($topicID))-&amp;gt;result_array();
//get edges
$sql = &quot;SELECT SourceID, TargetID, Width, View1, View2 FROM papermap_4_edge WHERE FieldID = ?;&quot;;
$edges = $this-&amp;gt;db_svg-&amp;gt;query($sql, array($topicID))-&amp;gt;result_array();
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;得到相应的点和边的数据之后，将其传到前端，绘制成svg即可。&lt;/p&gt;

&lt;h3 id=&quot;deferred&quot;&gt;Deferred对象&lt;/h3&gt;

&lt;p&gt;defered对象是jQuery的回调函数解决方案。这次我们在项目中使用到了这个技术，有两个目的，一是为了让一些点击事件的绑定能够生效，二是将一些地图其他的数据的读取放在地图显示之后。这些数据本身是依赖于地图的，缺少地图的话他们将无法显示完全。&lt;/p&gt;

&lt;p&gt;在使用上Deferred对象非常简单，如果要新建一个对象，执行下述代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var dtd = $.Deferred(); // 新建一个Deferred对象
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;jQuery规定，deferred对象有三种执行状态—-未完成，已完成和已失败。如果执行状态是”已完成”（resolved）,deferred对象立刻调用done()方法指定的回调函数；如果执行状态是”已失败”，调用fail()方法指定的回调函数；如果执行状态是”未完成”，则继续等待，或者调用progress()方法指定的回调函数。&lt;/p&gt;

&lt;p&gt;一般来说，我们指定“已完成”的状态居多。设定这个状态的代码为：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;dtd.resolve()
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ui&quot;&gt;UI界面&lt;/h3&gt;

&lt;p&gt;UI方面的话，我引入了bootstrap-standstone。相对来说还是比较美观，又带有些许严谨的风格，和“学术地图”这样的主题很相称。除此之外，我将领域的一些介绍内容也搬到了地图中，包括领域的父话题，子话题和该领域内发表论文数前50的作者。这样原本是两个页面，现在就合成一个页面了，风格也得到了统一。具体的话，还是直接来看对比图吧。&lt;/p&gt;

&lt;p&gt;之前的UI：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在的UI：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Acemap/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虽然我也不是专业的设计师，但我觉得还是美观了不少的。&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;做了其实也不少，剩下的开学之后再说吧！&lt;/p&gt;

</description>
        <pubDate>Tue, 14 Feb 2017 21:30:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/02/14/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E6%9E%84/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/02/14/Acemap%E5%AD%A6%E6%9C%AF%E5%9C%B0%E5%9B%BE%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E7%9A%84%E9%87%8D%E6%9E%84/</guid>
        
        <category>Acemap</category>
        
        <category>Javascript</category>
        
        <category>技术</category>
        
        
      </item>
    
      <item>
        <title>使用Processing制作交大饮食的可视化报告</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;序言&lt;/h2&gt;

&lt;p&gt;突然发现自己已经很久没有更新过博客了。主要原因是自己太闲了，大四上学期没有找什么实习，也没有课，在宿舍就是dota和日语的日子，所以就没有什么可以记录的啦。不过12月的时候，有个学弟让我帮他用Processing做一个可视化报告，我一口就答应了下来，因为有钱拿。&lt;/p&gt;

&lt;p&gt;其实我之前没有用过Processing，所以也是半学半用的在写代码。令人欣慰的是，Processing出奇的简单，学弟的这个大作业，我用了两天就做完了，惬意惬意。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;

&lt;h3 id=&quot;processing&quot;&gt;Processing介绍&lt;/h3&gt;

&lt;p&gt;我就不搬运什么网上的内容了，自己简单介绍一下Processing吧。&lt;/p&gt;

&lt;p&gt;Processing是一种可视化框架，也可以理解成一个Java框架。其所用的语言就是Java，有自己完善的生命周期以及基础接口函数。用起来非常简单直接暴力，所有文件中的变量和函数都是通用的，不需要什么MVC，MVVM这样的架构，一个页面就是一个文件，清晰明了。&lt;/p&gt;

&lt;p&gt;在我的理解中，Processing并不是写软件的框架，而仅仅是将数据用图像化的方式呈现出来。当然，PPT之类的软件可以做到这一点，但是从交互性和可控性来说，肯定没有Processing出色。&lt;/p&gt;

&lt;h3 id=&quot;processing-1&quot;&gt;Processing的生命周期&lt;/h3&gt;

&lt;p&gt;其实Processing的生命周期，好听点叫生命周期，难听点就是一个启动函数和一个刷新函数。怎么样，是不是很简单。&lt;/p&gt;

&lt;p&gt;页面加载时，调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void setup(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;页面刷新时，调用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void draw(){}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这里有一点要注意，draw()函数在每一帧都会调用，而且不会清除上一帧的图像。即使是静止的页面，也可能是无数层相同图像的叠加。因此在draw()函数的第一行，我们通常会手动清除页面上的内容。&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;实现时的一些编码细节&lt;/h3&gt;

&lt;p&gt;这次我们做的是2014-2015秋季学期交大闵行校区食堂的报告（1%取样），包括消费人群性别统计，学历统计。也有所有食堂在不同月份的总共的消费额。同时，调查了人均的挑费次数和消费额度，以及在交大二餐中最受欢迎的几种菜系。&lt;/p&gt;

&lt;p&gt;在使用Processing绘图的时候，可以设置一些模式，这些设置是可以被之后的设置所覆盖的。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;imageMode(CORNER);
image(back, 20, 20);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样我们就设置了image的绘制模式。如果在之后再次调用了imageMode但是传入了不同的参数，那么原来的CORNER模式会被覆盖掉。&lt;/p&gt;

&lt;p&gt;此外，由于所有的函数和变量是在不同文件中共享的，因此我在第一次加载的时候就想所有的数据都处理完毕，这样在之后的使用过程会流畅很多。&lt;/p&gt;

&lt;p&gt;所有使用到的变量如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;//all the data we need
float[] genderPortions = new float[2];
float[] educationPortions = new float[3];
int[][] volumnInMonths = new int[5][7];
int[][][] volumnInTime = new int[5][7][17];
int[][] volumnInPerson = new int[198][3];
String[][] topName = new String[3][3];
int[][] topValue = new int[3][3];
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;成果&lt;/h3&gt;

&lt;p&gt;下面放出几张最终效果图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Processing/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Processing/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Processing/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-4&quot;&gt;后记&lt;/h2&gt;

&lt;p&gt;虽然很久没有写代码了，但是每次接触到代码还是会很投入。接下来的目标是做好毕设，写好小程序外包，然后参加wwdc！&lt;/p&gt;

</description>
        <pubDate>Fri, 13 Jan 2017 21:30:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2017/01/13/%E4%BD%BF%E7%94%A8Processing%E5%88%B6%E4%BD%9C%E4%BA%A4%E5%A4%A7%E9%A5%AE%E9%A3%9F%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E5%91%8A/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2017/01/13/%E4%BD%BF%E7%94%A8Processing%E5%88%B6%E4%BD%9C%E4%BA%A4%E5%A4%A7%E9%A5%AE%E9%A3%9F%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E6%8A%A5%E5%91%8A/</guid>
        
        <category>Processing</category>
        
        <category>技术</category>
        
        <category>可视化</category>
        
        
      </item>
    
      <item>
        <title>Unity中使用Animation提高Animator的性能</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;序言&lt;/h2&gt;
&lt;p&gt;这次我要跟大家分享的是使用Animation来实现Animator的功能。其实效果没有之前Curve那么酷炫，但是工作量比之前的会大上好多。&lt;/p&gt;

&lt;p&gt;为什么要使用Animation来实现Animator呢？很大一部分原因是在于性能。Animator的性能是被人们所诟病的，在模拟之前我也不知道使用Animation能提高多少的性能，只是觉得可能是一种方式，所以就做了这件事。下面我们就进入正题，聊聊具体的方式。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;正文&lt;/h2&gt;
&lt;p&gt;平台：Unity 4.6&lt;/p&gt;

&lt;h3 id=&quot;section-2&quot;&gt;概念与运作方式&lt;/h3&gt;
&lt;p&gt;首先我们来明确一下Animator的概念以及运作方式。Animator本质上就是一个组件（Component），可以挂载到任意一个GameObject上，其核心在于AnimatorController。我们平常所看到的AnimatorController的图形化结构是这样的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/1.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;本质上而言，AnimatorController就是多个状态机的组合，其中的状态就是动画，而状态的转换就是动画的过渡。我们要实现的呢，就是状态机。只不过里面还有很多细节和其他功能比如Layer，BlendTree等。&lt;/p&gt;

&lt;p&gt;我们从宏观到微观的角度来看controller，序号越小表示所包含的东西越多，概念越大：
1. controller本身，其中主要是paramaters和各个layer的基本信息。
2. layer，在animator中，我们对每一个layer都需要进行state和transition的更新。
3. stateMachine，通常来说，一个layer就是一个stateMachine，但是stateMachine也可以包含其他的sub-stateMachine。
4. state和transition，这些都是包含在stateMachine中的，也是controller中最核心的部分。
5. animationClip，包含在一个state中，真正动画播放的东西。&lt;/p&gt;

&lt;p&gt;下面我们一个一个具体的介绍上述部件的功能。&lt;/p&gt;

&lt;h4 id=&quot;parameters&quot;&gt;Parameters&lt;/h4&gt;
&lt;p&gt;“参数”是用来控制Transition的发生的。当参数满足一个Transition触发的所有条件时，这个Transition就会执行。从图形化的角度来看，参数就是以下图来表示的：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/2.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们在代码中，可以通过SetInt，SetFloat等方法来修改参数的值。具体使用方法可以参考Unity手册。&lt;/p&gt;

&lt;h4 id=&quot;layer&quot;&gt;Layer&lt;/h4&gt;
&lt;p&gt;Layer在AnimatorController中，表示如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/3.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;他的作用主要是用来控制不同层动画的混合，比如你有一个投掷的动画和一个走路的动画，你想上半身来投掷，下半身 走路的话，就可以通过Layer来实现。在Layer中我们看到有weight，Mask和Blending可以供开发者选择。weight用来控制混合 的权重，0表示不混合（动画不播放），其他数值会以一个融合的比重来播放动画，这里weight的值并不是绝对的，还会根据Blending的选择来更 改，如果Blending为Override，那么最终播放的时候当前层的动画会覆盖更浅层的动画，如果Blending为Additive，那么当前层 的weight会与更浅层的weight相加，再归一化。Mask是用来控制当前Layer的动画使用在身体的哪个部分的。我们可以在Unity中创建一 个Mask Avatar，通过设置它来达到控制身体部位的效果。&lt;/p&gt;

&lt;h4 id=&quot;statemachine&quot;&gt;StateMachine&lt;/h4&gt;

&lt;p&gt;一个StateMachine就是一个状态机，也就是我们最直观的看到的那一块区域：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/4.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;通常来说，一个layer就是一个stateMachine，但是stateMachine也可以包含其他的sub-stateMachine。&lt;/p&gt;

&lt;h4 id=&quot;state&quot;&gt;State&lt;/h4&gt;
&lt;p&gt;State在AnimatorController中表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/5.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;实际上，一个State就包含了一个动画或者多个动画的融合（BlendTree）。在每一个State中，我们都可以找到AnimationClip，而它就是真正被播放的东西。我们状态机就是在不同的State之间进行转换，也就是在不同的动画中进行过渡与播放。值得一提的是，我们有一个很特殊的State叫AnyState，它可以表示任何一个State，换句话说，从它发出的Transition可以看作是从其他State中发出的。&lt;/p&gt;

&lt;h4 id=&quot;transition&quot;&gt;Transition&lt;/h4&gt;
&lt;p&gt;Transition就是在AnimatorController中的箭头，表示为：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/6.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当我们选中一个Transition时，可以在右边看到触发时的条件，这些条件必须全部都满足时才会被触发。Transition是一个动画到另一个动画的过渡，这个过渡是有时间的。当过渡完成之后，动画的状态才会切换。有一类Transition的条件仅仅是Exit Time，表示当动画播放了一段时间后自动会触发这个Transition。&lt;/p&gt;

&lt;p&gt;具体我们模拟Animator的时候，可以这么做（Update函数）：
1. 遍历每一个layer（可用多线程）
2. 在一个layer中，遍历当前state发出的所有transition，看看是否有所有conditions都满足的transition
3. 如果没有，结束
4. 如果有，则开始这个transition
5. transition是有时间的，所以当transition结束后，将当前的state设置成transition的dstState&lt;/p&gt;

&lt;h3 id=&quot;section-3&quot;&gt;实现&lt;/h3&gt;

&lt;h4 id=&quot;section-4&quot;&gt;解析&lt;/h4&gt;
&lt;p&gt;在实现这个Animator的时候，因为我们使用的是Unity 4.6，并没有与AnimatorController相关的API，所以我们需要自己解析controller文件。如果要看到controller文 件的原内容，我们需要设置一下Project Setting - Edtior，将其中的Aseet Serialization设置为Force Text，然后将controller文件使用任意编辑器打开（sublime），就能看到controller中所有的数据结构啦。我们在实际解析这些数据结构的时候，可以在代码中直接创建相应的类和成员变量，以State为例，在controller中他是这么表示的：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gd&quot;&gt;--- !u!1102 &amp;amp;110273390
&lt;/span&gt;State:
  m_ObjectHideFlags: 3
  m_PrefabParentObject: {fileID: 0}
  m_PrefabInternal: {fileID: 0}
  m_Name: Attack01
  m_Speed: 1
  m_CycleOffset: 0
  m_Motions:
  - {fileID: 7400000, guid: 904f2f79e9c87534f903a673c7adb132, type: 3}
  m_ParentStateMachine: {fileID: 110728656}
  m_Position: {x: -94, y: 183, z: 0}
  m_IKOnFeet: 0
  m_Mirror: 0
  m_Tag: 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们创建的类如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class State
{
    public int m_id;
    public string m_Name;
    public float m_Speed;
    public float m_CycleOffset;
    public bool m_IKOnFeet;
    public bool m_Mirror;

    public List&amp;lt;AnimationClip&amp;gt; m_Motions; // one motion per motion set  
    public BlendTree m_MotionsWithBlendTree;

    public StateMachine m_ParentStateMachine;
    public Vector3 m_Position;
    public string m_Tag;

    public State(int id)
    {
        m_id = id;
        m_Motions = new List&amp;lt;AnimationClip&amp;gt;();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，id为controller中第一行最后的那一串数字，其他的成员变量名字和controller中的大致都是一样的。因为一个 State可能是一个BlendTree，所以我们添加了一个m_MotionsWithBlendTree来表示这个State对应的 BlendTree（如果有的话）。然后，m_Motions存储的就是要被Animation播放的动画片段。&lt;/p&gt;

&lt;p&gt;这里有一点需要注意，我们需要将原来的动画片段复制一遍，把他的animationType设置成Lagecy，才能被Animation所支持。具体复制和设置的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;string animationPath = &quot;Assets/Character/Animations/&quot; + guid + state.m_id + &quot;.FBX&quot;;
//AssetDatabase.CopyAsset(AssetDatabase.GUIDToAssetPath(guid), animationPath);
var animationObject = AssetDatabase.LoadAssetAtPath(animationPath, typeof(AnimationClip)) as AnimationClip;
if (!animationObject.name.Contains(state.m_id.ToString()))
      animationObject.name = animationObject.name + state.m_id;
AnimationUtility.SetAnimationType(animationObject, ModelImporterAnimationType.Legacy);
state.m_Motions.Add(animationObject);
state.m_MotionsWithBlendTree = null;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在上述代码中我们发现，我们对animationClip的名字进行的修改，原因在于，可能在不同Layer的两个State中有相同的AnimationClip，他们完全可以同时进行播放。在controller中，他们也是以不同的guid来表示的，说明他们是两个对象。而在Animation中，我们的Clip是以名字进行标识的，所以这里要给他们换一个名字。&lt;/p&gt;

&lt;p&gt;最后一点需要注意的是，还记不记得我们之前说在Layer中可以添加Mask。我们打开.mask文件后，发现会有一些m_Path，我们把m_Weight为1的所有path当成字符串保存起来，之后在模拟的时候会使用到。&lt;/p&gt;

&lt;h4 id=&quot;section-5&quot;&gt;模拟&lt;/h4&gt;

&lt;p&gt;解析完controller文件后，就可以模拟Animator的行为了。&lt;/p&gt;

&lt;p&gt;首先我们要将所有的动画添加到Animation中去，在添加的时候，可以设置AnimationState.layer来实现不同layer的混合效果， 然后我们要实现mask的效果，可以使用函数AddMixingTransform，他接受两个参数，一个是transform，这里我们就可以使用解析 得到的m_Path了，使用transform.find(m_Path)就能得到我们真正需要的子transform（也就是mask），另一个参数表 示是否递归，这里根据.mask的文件结构来看，我们选择false即可。&lt;/p&gt;

&lt;p&gt;另外需要注意的是，Animation没有直观的数据结构可以表示BlendTree，我们要根据parameter的值以及各个动画片段的threshold来计算出他们的权重。这里以1D为例，计算权重的函数如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;void UpdateWeightsAndSpeedsInBlendTree1D(AnimatorCompiler.BlendTree blendTree)
{
      float para = floatConditions[blendTree.m_BlendParameter.m_Name];
      AnimatorCompiler.BlendTree.Child left = null;
      AnimatorCompiler.BlendTree.Child right = null;
      for (int i = 0; i &amp;lt; blendTree.m_Childs.Count; ++i)
      {
            AnimatorCompiler.BlendTree.Child child = blendTree.m_Childs[i];
            if (para &amp;gt;= child.m_Threshold &amp;amp;&amp;amp; child.m_Threshold &amp;lt; blendTree.m_MaxThreshold)
            {
                  if (left == null || child.m_Threshold &amp;gt; left.m_Threshold)
                  {
                        left = child;
                  }
            }
            else if (para &amp;lt;= child.m_Threshold)
            {
                  if (right == null || child.m_Threshold &amp;lt; right.m_Threshold)
                  {
                        right = child;
                  }
            }
            weightInBlendTrees[blendTree][child] = 0.0f;
            speedInBlendTrees[blendTree][child] = 0.0f;
      }
      if (left != null &amp;amp;&amp;amp; right != null)
      {
            float lp = 1 - (para - left.m_Threshold) / (right.m_Threshold - left.m_Threshold);
            float rp = 1 - lp;
            weightInBlendTrees[blendTree][left] = lp;
            weightInBlendTrees[blendTree][right] = rp;
            float leftTime = left.m_Motion.length / left.m_TimeScale;
            float rightTime = right.m_Motion.length / right.m_TimeScale;
            speedInBlendTrees[blendTree][left] = left.m_Motion.length / (leftTime * lp + rightTime * rp);
            speedInBlendTrees[blendTree][right] = right.m_Motion.length / (leftTime * lp + rightTime * rp);
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;1D还是比较简单的，找到与parameter的值相邻的两个threshold，然后对这两个threshold所表示的AnimationClip的weight进行插值即可。2D的weight计算可以参考&lt;a href=&quot;http://runevision.com/thesis/rune_skovbo_johansen_thesis.pdf&quot;&gt;这篇文章&lt;/a&gt;的6.3节。&lt;/p&gt;

&lt;p&gt;大部分的更新Transition的逻辑都在Update函数中完成，那么我们要怎么来模拟这个Transition的过程呢？一种比较显然的方法是使用CrossFade，我们来看看CrossFade的函数原型。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void CrossFade(string animation, float fadeLength = 0.3F, PlayMode mode = PlayMode.StopSameLayer);
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;animation为我们的目标动画，fadeLength就是过渡的时间，也就是transition的时间。我们解析得到的m_TransitionDuration是一个百分比，需要乘上原动画的时间。 CrossFade的原理是，将animation的weight设置成1，enable设置成true，然后在fadeLength的时间内将原动画的 weight降为0，再把他的enable设置成false。这样就有一个问题，在blendTree中的动画不一定weight就为1，而且在高层的 Layer中的weight也不一定为1，所以我们不能直接使用CrossFade，而是自己将它实现一遍再进行一些修改，大致的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;foreach (var item in parser.animation.m_State)
{
      AnimatorCompiler.State state = item.Value;
      if (state.m_id == 0)
            continue;
      if (state.m_ParentStateMachine.m_Index == layer.m_Index)
      {
            if (state.m_id != transition.m_DstState.m_id)
            {
                  if (state.m_MotionsWithBlendTree == null)
                  {
                        gameObject.animation.Blend(state.m_Motions[0].name, 0, currentTransitionInLayers[layer].m_TransitionDuration * animationLength);
                  }
                  else
                  {
                        for (int j = 0; j &amp;lt; state.m_MotionsWithBlendTree.m_Childs.Count; ++j)
                        {
                              AnimatorCompiler.BlendTree.Child child = state.m_MotionsWithBlendTree.m_Childs[j];
                              gameObject.animation.Blend(child.m_Motion.name, 0, currentTransitionInLayers[layer].m_TransitionDuration * animationLength);
                        }
                  }
            }
      }
}
if (currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree == null)
{
      gameObject.animation.Stop(transition.m_DstState.m_Motions[0].name);
      gameObject.animation[transition.m_DstState.m_Motions[0].name].enabled = true;
      gameObject.animation[transition.m_DstState.m_Motions[0].name].weight = ((layer.m_Index == 0) ? 1 : layer.m_DefaultWeight);
}
else
{
      for (int i = 0; i &amp;lt; currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree.m_Childs.Count; ++i)
      {
            AnimatorCompiler.BlendTree.Child child = currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree.m_Childs[i];
            gameObject.animation.Stop(child.m_Motion.name);
            gameObject.animation[child.m_Motion.name].enabled = true;
            gameObject.animation[child.m_Motion.name].weight = weightInBlendTrees[currentTransitionInLayers[layer].m_DstState.m_MotionsWithBlendTree][child];
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;剩下的部分只要细心耐心的按照animator模拟的步骤慢慢实现即可，没有什么太多的坑。&lt;/p&gt;

&lt;h3 id=&quot;section-6&quot;&gt;改进&lt;/h3&gt;

&lt;p&gt;好了，如果你按照上述的步骤写完了，然后想打包一下跃跃欲试，你会发现你失败了。原因是我们在复制AnimationClip的时候，使用了AssetDatabase，他是属于UnityEditor的一个类，而UnityEditor无法打包。因此我们需要把解析的过程放在Editor中完成，然后将解析的结果都串行化，保存起来。&lt;/p&gt;

&lt;p&gt;你可以小心翼翼的在每个类上面加上[System.Serializable]，但是这么做依然是不行的，因为我们在类中表示其他的对象时，使用都是其他对象的指针，所以很容易就产生循环引用，在Editor中无法被串行化，例如，state类中有一个parentStateMachine指向一个StateMachine，而在一个StateMachine中又保存了他所有state的指针。&lt;/p&gt;

&lt;p&gt;因此，我们需要修改整个解析得到的类的数据结构，将指针替换为对象的id（int类型）。以State为例，我们可以与之前的代码进行对比：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[System.Serializable]
public class State
{
      public int m_id;
      public string m_Name;
      public float m_Speed;
      public float m_CycleOffset;
      public bool m_IKOnFeet;
      public bool m_Mirror;

      public List&amp;lt;AnimationClip&amp;gt; m_Motions; // one motion per motion set    
      public int m_MotionsWithBlendTree;

      public int m_ParentStateMachine;
      public Vector3 m_Position;
      public string m_Tag;

      public State(int id)
      {
            m_id = id;
            m_Motions = new List&amp;lt;AnimationClip&amp;gt;();
            m_MotionsWithBlendTree = -1;
      }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于我们把解析的过程放在了Editor中完成，因此运行的速度也会更快一些。&lt;/p&gt;

&lt;p&gt;那么我们还有什么办法可以提高性能吗？&lt;/p&gt;

&lt;p&gt;答案肯定是有的，这里就采用了“生成代码”的办法。我们真正运行时的逻辑代码，是在Editor中生成的，而不是提前写好的。可能听起来有点绕，我把我的工程的文件结构给大家看一下：&lt;/p&gt;

&lt;p&gt;Editor：
- AnimatorCodeGenerator.cs：生成模拟Animator的代码
- AnimatorParser：解析controller文件&lt;/p&gt;

&lt;p&gt;Scripts：
- AnimationByAnimator：模拟Animator
- AnimationController：控制gameObject
- AnimatorCompiler：controller文件的数据结构
- AnimatorData：用来存储解析controller文件后的结果
- CodeUtil：生成代码时使用的工具&lt;/p&gt;

&lt;p&gt;这样应该清晰了很多，那么这么做有什么好处呢？&lt;/p&gt;

&lt;p&gt;如果我们平常来写的话，必然会使用到大量的字典，比如parentStateMachineInStates，我们在解析的数据结构 中，parentStateMachine保存的是StateMachine的Id，只有id是没有办法直接在模拟代码中使用的，我们要把这个id换转成 真正的StateMachine的对象，因此他在模拟代码中的类型应该是Dictionary&amp;lt;State, StateMachine&amp;gt;。由于使用字典会产生大量的cache miss，因此性能并不出色。而生成代码最大的优势是能循环展开并且避免使用字典，其原理就在于能够“通过不同的字符串来运用变量”。&lt;/p&gt;

&lt;p&gt;我们来看一个例子，在codeGenerator中，有这样的一段代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (int i = 0; i &amp;lt; animation.m_Transition.Count; ++i)
{
      AnimatorCompiler.Transition transition = animation.m_Transition[i];
      code.Variable(&quot;&quot;, &quot;AnimatorCompiler.State&quot;, code.Normalize(&quot;srcStateInTransitions_&quot; + transition.m_id));
      code.Variable(&quot;&quot;, &quot;AnimatorCompiler.State&quot;, code.Normalize(&quot;dstStateInTransitions_&quot; + transition.m_id));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Variable函数就是创建响应的变量名。运行这段代码，生成的代码如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;AnimatorCompiler.State srcStateInTransitions_110100396;
AnimatorCompiler.State dstStateInTransitions_110100396;
AnimatorCompiler.State srcStateInTransitions_110128666;
AnimatorCompiler.State dstStateInTransitions_110128666;
AnimatorCompiler.State srcStateInTransitions_110144588;
AnimatorCompiler.State dstStateInTransitions_110144588;
AnimatorCompiler.State srcStateInTransitions_110150974;
AnimatorCompiler.State dstStateInTransitions_110150974;
AnimatorCompiler.State srcStateInTransitions_110152432;
AnimatorCompiler.State dstStateInTransitions_110152432;
AnimatorCompiler.State srcStateInTransitions_110183908;
AnimatorCompiler.State dstStateInTransitions_110183908;
AnimatorCompiler.State srcStateInTransitions_110193682;
AnimatorCompiler.State dstStateInTransitions_110193682;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，原先的Dictionary被展开成了不同的变量，而且我们把循环函数放在了Editor中完成，因此运行时的效率会更高一些。而这些就是生成代码所给我们带来的好处。&lt;/p&gt;

&lt;p&gt;不过，生成代码非常非常容易出错，大家在写的时候一定要仔细！&lt;/p&gt;

&lt;h2 id=&quot;section-7&quot;&gt;性能&lt;/h2&gt;

&lt;p&gt;测试时，我们重点关注Update函数消耗的时间，无论是Animator还是我们写的这个系统，Update函数始终都是核心，也是最最耗时的一部分。&lt;/p&gt;

&lt;p&gt;这次我们依然在安卓机上测试，创建300个物体，先挂上Animator，得到的图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/7.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以看到，所有Update函数的时间和为40.74+19.41=60.15ms。&lt;/p&gt;

&lt;p&gt;现在我们来看看用我们的系统：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/in-post/Animation/8.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;总的Update函数时间为17.82+10.95+5.85=34.62ms。&lt;/p&gt;

&lt;p&gt;我们可以看到，在平均情况下，Animation实现的系统已经比Animator快了接近一倍，而在实现中可以优化的地方依旧有很多，代码也不是最美观，如果你有什么好的建议，欢迎联系我！&lt;/p&gt;

</description>
        <pubDate>Fri, 09 Sep 2016 13:00:00 +0000</pubDate>
        <link>https://gougoumemeda.github.io/2016/09/09/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Animation%E6%8F%90%E9%AB%98Animator%E7%9A%84%E6%80%A7%E8%83%BD/</link>
        <guid isPermaLink="true">https://gougoumemeda.github.io/2016/09/09/Unity%E4%B8%AD%E4%BD%BF%E7%94%A8Animation%E6%8F%90%E9%AB%98Animator%E7%9A%84%E6%80%A7%E8%83%BD/</guid>
        
        <category>Unity</category>
        
        <category>技术</category>
        
        <category>腾讯</category>
        
        
      </item>
    
  </channel>
</rss>
